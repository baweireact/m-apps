{"version":3,"file":"index.86885eb4.js","sources":["../../vite/dynamic-import-polyfill","../../node_modules/vue-router/dist/vue-router.esm-bundler.js","../../vite/preload-helper","../../src/router/light.js","../../src/router/index.js","../../src/api/lightUrls.js","../../src/api/urls.js","../../node_modules/axios/lib/helpers/bind.js","../../node_modules/axios/lib/utils.js","../../node_modules/axios/lib/helpers/buildURL.js","../../node_modules/axios/lib/core/InterceptorManager.js","../../node_modules/axios/lib/core/transformData.js","../../node_modules/axios/lib/cancel/isCancel.js","../../node_modules/axios/lib/helpers/normalizeHeaderName.js","../../node_modules/axios/lib/core/createError.js","../../node_modules/axios/lib/core/enhanceError.js","../../node_modules/axios/lib/helpers/cookies.js","../../node_modules/axios/lib/helpers/parseHeaders.js","../../node_modules/axios/lib/helpers/isURLSameOrigin.js","../../node_modules/axios/lib/adapters/xhr.js","../../node_modules/axios/lib/core/buildFullPath.js","../../node_modules/axios/lib/helpers/isAbsoluteURL.js","../../node_modules/axios/lib/helpers/combineURLs.js","../../node_modules/axios/lib/core/settle.js","../../node_modules/axios/lib/defaults.js","../../node_modules/axios/lib/core/dispatchRequest.js","../../node_modules/axios/lib/core/mergeConfig.js","../../node_modules/axios/lib/core/Axios.js","../../node_modules/axios/lib/cancel/Cancel.js","../../node_modules/axios/lib/cancel/CancelToken.js","../../node_modules/axios/lib/axios.js","../../node_modules/axios/lib/helpers/spread.js","../../node_modules/axios/lib/helpers/isAxiosError.js","../../node_modules/axios/index.js","../../src/api/common.js","../../src/api/index.js","../../src/api/lightApi.js","../../src/store/light/actions.js","../../src/store/index.js","../../src/store/light/index.js","../../src/main.js"],"sourcesContent":["const p = function polyfill(modulePath = '.', importFunctionName = '__import__') {\n    try {\n        self[importFunctionName] = new Function('u', `return import(u)`);\n    }\n    catch (error) {\n        const baseURL = new URL(modulePath, location);\n        const cleanup = (script) => {\n            URL.revokeObjectURL(script.src);\n            script.remove();\n        };\n        self[importFunctionName] = (url) => new Promise((resolve, reject) => {\n            const absURL = new URL(url, baseURL);\n            // If the module has already been imported, resolve immediately.\n            if (self[importFunctionName].moduleMap[absURL]) {\n                return resolve(self[importFunctionName].moduleMap[absURL]);\n            }\n            const moduleBlob = new Blob([\n                `import * as m from '${absURL}';`,\n                `${importFunctionName}.moduleMap['${absURL}']=m;`\n            ], { type: 'text/javascript' });\n            const script = Object.assign(document.createElement('script'), {\n                type: 'module',\n                src: URL.createObjectURL(moduleBlob),\n                onerror() {\n                    reject(new Error(`Failed to import: ${url}`));\n                    cleanup(script);\n                },\n                onload() {\n                    resolve(self[importFunctionName].moduleMap[absURL]);\n                    cleanup(script);\n                }\n            });\n            document.head.appendChild(script);\n        });\n        self[importFunctionName].moduleMap = {};\n    }\n};__VITE_IS_MODERN__&&p(\"/assets/\");","/*!\n  * vue-router v4.0.8\n  * (c) 2021 Eduardo San Martin Morote\n  * @license MIT\n  */\nimport { getCurrentInstance, inject, onUnmounted, onDeactivated, onActivated, computed, unref, defineComponent, reactive, watchEffect, h, provide, ref, watch, shallowRef, nextTick } from 'vue';\nimport { setupDevtoolsPlugin } from '@vue/devtools-api';\n\nconst hasSymbol = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';\r\nconst PolySymbol = (name) => \r\n// vr = vue router\r\nhasSymbol\r\n    ? Symbol((process.env.NODE_ENV !== 'production') ? '[vue-router]: ' + name : name)\r\n    : ((process.env.NODE_ENV !== 'production') ? '[vue-router]: ' : '_vr_') + name;\r\n// rvlm = Router View Location Matched\r\n/**\r\n * RouteRecord being rendered by the closest ancestor Router View. Used for\r\n * `onBeforeRouteUpdate` and `onBeforeRouteLeave`. rvlm stands for Router View\r\n * Location Matched\r\n *\r\n * @internal\r\n */\r\nconst matchedRouteKey = /*#__PURE__*/ PolySymbol((process.env.NODE_ENV !== 'production') ? 'router view location matched' : 'rvlm');\r\n/**\r\n * Allows overriding the router view depth to control which component in\r\n * `matched` is rendered. rvd stands for Router View Depth\r\n *\r\n * @internal\r\n */\r\nconst viewDepthKey = /*#__PURE__*/ PolySymbol((process.env.NODE_ENV !== 'production') ? 'router view depth' : 'rvd');\r\n/**\r\n * Allows overriding the router instance returned by `useRouter` in tests. r\r\n * stands for router\r\n *\r\n * @internal\r\n */\r\nconst routerKey = /*#__PURE__*/ PolySymbol((process.env.NODE_ENV !== 'production') ? 'router' : 'r');\r\n/**\r\n * Allows overriding the current route returned by `useRoute` in tests. rl\r\n * stands for route location\r\n *\r\n * @internal\r\n */\r\nconst routeLocationKey = /*#__PURE__*/ PolySymbol((process.env.NODE_ENV !== 'production') ? 'route location' : 'rl');\r\n/**\r\n * Allows overriding the current route used by router-view. Internally this is\r\n * used when the `route` prop is passed.\r\n *\r\n * @internal\r\n */\r\nconst routerViewLocationKey = /*#__PURE__*/ PolySymbol((process.env.NODE_ENV !== 'production') ? 'router view location' : 'rvl');\n\nconst isBrowser = typeof window !== 'undefined';\n\nfunction isESModule(obj) {\r\n    return obj.__esModule || (hasSymbol && obj[Symbol.toStringTag] === 'Module');\r\n}\r\nconst assign = Object.assign;\r\nfunction applyToParams(fn, params) {\r\n    const newParams = {};\r\n    for (const key in params) {\r\n        const value = params[key];\r\n        newParams[key] = Array.isArray(value) ? value.map(fn) : fn(value);\r\n    }\r\n    return newParams;\r\n}\r\nlet noop = () => { };\n\nfunction warn(msg) {\r\n    // avoid using ...args as it breaks in older Edge builds\r\n    const args = Array.from(arguments).slice(1);\r\n    console.warn.apply(console, ['[Vue Router warn]: ' + msg].concat(args));\r\n}\n\nconst TRAILING_SLASH_RE = /\\/$/;\r\nconst removeTrailingSlash = (path) => path.replace(TRAILING_SLASH_RE, '');\r\n/**\r\n * Transforms an URI into a normalized history location\r\n *\r\n * @param parseQuery\r\n * @param location - URI to normalize\r\n * @param currentLocation - current absolute location. Allows resolving relative\r\n * paths. Must start with `/`. Defaults to `/`\r\n * @returns a normalized history location\r\n */\r\nfunction parseURL(parseQuery, location, currentLocation = '/') {\r\n    let path, query = {}, searchString = '', hash = '';\r\n    // Could use URL and URLSearchParams but IE 11 doesn't support it\r\n    const searchPos = location.indexOf('?');\r\n    const hashPos = location.indexOf('#', searchPos > -1 ? searchPos : 0);\r\n    if (searchPos > -1) {\r\n        path = location.slice(0, searchPos);\r\n        searchString = location.slice(searchPos + 1, hashPos > -1 ? hashPos : location.length);\r\n        query = parseQuery(searchString);\r\n    }\r\n    if (hashPos > -1) {\r\n        path = path || location.slice(0, hashPos);\r\n        // keep the # character\r\n        hash = location.slice(hashPos, location.length);\r\n    }\r\n    // no search and no query\r\n    path = resolveRelativePath(path != null ? path : location, currentLocation);\r\n    // empty path means a relative query or hash `?foo=f`, `#thing`\r\n    return {\r\n        fullPath: path + (searchString && '?') + searchString + hash,\r\n        path,\r\n        query,\r\n        hash,\r\n    };\r\n}\r\n/**\r\n * Stringifies a URL object\r\n *\r\n * @param stringifyQuery\r\n * @param location\r\n */\r\nfunction stringifyURL(stringifyQuery, location) {\r\n    let query = location.query ? stringifyQuery(location.query) : '';\r\n    return location.path + (query && '?') + query + (location.hash || '');\r\n}\r\n/**\r\n * Strips off the base from the beginning of a location.pathname in a non\r\n * case-sensitive way.\r\n *\r\n * @param pathname - location.pathname\r\n * @param base - base to strip off\r\n */\r\nfunction stripBase(pathname, base) {\r\n    // no base or base is not found at the beginning\r\n    if (!base || pathname.toLowerCase().indexOf(base.toLowerCase()))\r\n        return pathname;\r\n    return pathname.slice(base.length) || '/';\r\n}\r\n/**\r\n * Checks if two RouteLocation are equal. This means that both locations are\r\n * pointing towards the same {@link RouteRecord} and that all `params`, `query`\r\n * parameters and `hash` are the same\r\n *\r\n * @param a - first {@link RouteLocation}\r\n * @param b - second {@link RouteLocation}\r\n */\r\nfunction isSameRouteLocation(stringifyQuery, a, b) {\r\n    let aLastIndex = a.matched.length - 1;\r\n    let bLastIndex = b.matched.length - 1;\r\n    return (aLastIndex > -1 &&\r\n        aLastIndex === bLastIndex &&\r\n        isSameRouteRecord(a.matched[aLastIndex], b.matched[bLastIndex]) &&\r\n        isSameRouteLocationParams(a.params, b.params) &&\r\n        stringifyQuery(a.query) === stringifyQuery(b.query) &&\r\n        a.hash === b.hash);\r\n}\r\n/**\r\n * Check if two `RouteRecords` are equal. Takes into account aliases: they are\r\n * considered equal to the `RouteRecord` they are aliasing.\r\n *\r\n * @param a - first {@link RouteRecord}\r\n * @param b - second {@link RouteRecord}\r\n */\r\nfunction isSameRouteRecord(a, b) {\r\n    // since the original record has an undefined value for aliasOf\r\n    // but all aliases point to the original record, this will always compare\r\n    // the original record\r\n    return (a.aliasOf || a) === (b.aliasOf || b);\r\n}\r\nfunction isSameRouteLocationParams(a, b) {\r\n    if (Object.keys(a).length !== Object.keys(b).length)\r\n        return false;\r\n    for (let key in a) {\r\n        if (!isSameRouteLocationParamsValue(a[key], b[key]))\r\n            return false;\r\n    }\r\n    return true;\r\n}\r\nfunction isSameRouteLocationParamsValue(a, b) {\r\n    return Array.isArray(a)\r\n        ? isEquivalentArray(a, b)\r\n        : Array.isArray(b)\r\n            ? isEquivalentArray(b, a)\r\n            : a === b;\r\n}\r\n/**\r\n * Check if two arrays are the same or if an array with one single entry is the\r\n * same as another primitive value. Used to check query and parameters\r\n *\r\n * @param a - array of values\r\n * @param b - array of values or a single value\r\n */\r\nfunction isEquivalentArray(a, b) {\r\n    return Array.isArray(b)\r\n        ? a.length === b.length && a.every((value, i) => value === b[i])\r\n        : a.length === 1 && a[0] === b;\r\n}\r\n/**\r\n * Resolves a relative path that starts with `.`.\r\n *\r\n * @param to - path location we are resolving\r\n * @param from - currentLocation.path, should start with `/`\r\n */\r\nfunction resolveRelativePath(to, from) {\r\n    if (to.startsWith('/'))\r\n        return to;\r\n    if ((process.env.NODE_ENV !== 'production') && !from.startsWith('/')) {\r\n        warn(`Cannot resolve a relative location without an absolute path. Trying to resolve \"${to}\" from \"${from}\". It should look like \"/${from}\".`);\r\n        return to;\r\n    }\r\n    if (!to)\r\n        return from;\r\n    const fromSegments = from.split('/');\r\n    const toSegments = to.split('/');\r\n    let position = fromSegments.length - 1;\r\n    let toPosition;\r\n    let segment;\r\n    for (toPosition = 0; toPosition < toSegments.length; toPosition++) {\r\n        segment = toSegments[toPosition];\r\n        // can't go below zero\r\n        if (position === 1 || segment === '.')\r\n            continue;\r\n        if (segment === '..')\r\n            position--;\r\n        // found something that is not relative path\r\n        else\r\n            break;\r\n    }\r\n    return (fromSegments.slice(0, position).join('/') +\r\n        '/' +\r\n        toSegments\r\n            .slice(toPosition - (toPosition === toSegments.length ? 1 : 0))\r\n            .join('/'));\r\n}\n\nvar NavigationType;\r\n(function (NavigationType) {\r\n    NavigationType[\"pop\"] = \"pop\";\r\n    NavigationType[\"push\"] = \"push\";\r\n})(NavigationType || (NavigationType = {}));\r\nvar NavigationDirection;\r\n(function (NavigationDirection) {\r\n    NavigationDirection[\"back\"] = \"back\";\r\n    NavigationDirection[\"forward\"] = \"forward\";\r\n    NavigationDirection[\"unknown\"] = \"\";\r\n})(NavigationDirection || (NavigationDirection = {}));\r\n/**\r\n * Starting location for Histories\r\n */\r\nconst START = '';\r\n// Generic utils\r\n/**\r\n * Normalizes a base by removing any trailing slash and reading the base tag if\r\n * present.\r\n *\r\n * @param base - base to normalize\r\n */\r\nfunction normalizeBase(base) {\r\n    if (!base) {\r\n        if (isBrowser) {\r\n            // respect <base> tag\r\n            const baseEl = document.querySelector('base');\r\n            base = (baseEl && baseEl.getAttribute('href')) || '/';\r\n            // strip full URL origin\r\n            base = base.replace(/^\\w+:\\/\\/[^\\/]+/, '');\r\n        }\r\n        else {\r\n            base = '/';\r\n        }\r\n    }\r\n    // ensure leading slash when it was removed by the regex above avoid leading\r\n    // slash with hash because the file could be read from the disk like file://\r\n    // and the leading slash would cause problems\r\n    if (base[0] !== '/' && base[0] !== '#')\r\n        base = '/' + base;\r\n    // remove the trailing slash so all other method can just do `base + fullPath`\r\n    // to build an href\r\n    return removeTrailingSlash(base);\r\n}\r\n// remove any character before the hash\r\nconst BEFORE_HASH_RE = /^[^#]+#/;\r\nfunction createHref(base, location) {\r\n    return base.replace(BEFORE_HASH_RE, '#') + location;\r\n}\n\nfunction getElementPosition(el, offset) {\r\n    const docRect = document.documentElement.getBoundingClientRect();\r\n    const elRect = el.getBoundingClientRect();\r\n    return {\r\n        behavior: offset.behavior,\r\n        left: elRect.left - docRect.left - (offset.left || 0),\r\n        top: elRect.top - docRect.top - (offset.top || 0),\r\n    };\r\n}\r\nconst computeScrollPosition = () => ({\r\n    left: window.pageXOffset,\r\n    top: window.pageYOffset,\r\n});\r\nfunction scrollToPosition(position) {\r\n    let scrollToOptions;\r\n    if ('el' in position) {\r\n        let positionEl = position.el;\r\n        const isIdSelector = typeof positionEl === 'string' && positionEl.startsWith('#');\r\n        /**\r\n         * `id`s can accept pretty much any characters, including CSS combinators\r\n         * like `>` or `~`. It's still possible to retrieve elements using\r\n         * `document.getElementById('~')` but it needs to be escaped when using\r\n         * `document.querySelector('#\\\\~')` for it to be valid. The only\r\n         * requirements for `id`s are them to be unique on the page and to not be\r\n         * empty (`id=\"\"`). Because of that, when passing an id selector, it should\r\n         * be properly escaped for it to work with `querySelector`. We could check\r\n         * for the id selector to be simple (no CSS combinators `+ >~`) but that\r\n         * would make things inconsistent since they are valid characters for an\r\n         * `id` but would need to be escaped when using `querySelector`, breaking\r\n         * their usage and ending up in no selector returned. Selectors need to be\r\n         * escaped:\r\n         *\r\n         * - `#1-thing` becomes `#\\31 -thing`\r\n         * - `#with~symbols` becomes `#with\\\\~symbols`\r\n         *\r\n         * - More information about  the topic can be found at\r\n         *   https://mathiasbynens.be/notes/html5-id-class.\r\n         * - Practical example: https://mathiasbynens.be/demo/html5-id\r\n         */\r\n        if ((process.env.NODE_ENV !== 'production') && typeof position.el === 'string') {\r\n            if (!isIdSelector || !document.getElementById(position.el.slice(1))) {\r\n                try {\r\n                    let foundEl = document.querySelector(position.el);\r\n                    if (isIdSelector && foundEl) {\r\n                        warn(`The selector \"${position.el}\" should be passed as \"el: document.querySelector('${position.el}')\" because it starts with \"#\".`);\r\n                        // return to avoid other warnings\r\n                        return;\r\n                    }\r\n                }\r\n                catch (err) {\r\n                    warn(`The selector \"${position.el}\" is invalid. If you are using an id selector, make sure to escape it. You can find more information about escaping characters in selectors at https://mathiasbynens.be/notes/css-escapes or use CSS.escape (https://developer.mozilla.org/en-US/docs/Web/API/CSS/escape).`);\r\n                    // return to avoid other warnings\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n        const el = typeof positionEl === 'string'\r\n            ? isIdSelector\r\n                ? document.getElementById(positionEl.slice(1))\r\n                : document.querySelector(positionEl)\r\n            : positionEl;\r\n        if (!el) {\r\n            (process.env.NODE_ENV !== 'production') &&\r\n                warn(`Couldn't find element using selector \"${position.el}\" returned by scrollBehavior.`);\r\n            return;\r\n        }\r\n        scrollToOptions = getElementPosition(el, position);\r\n    }\r\n    else {\r\n        scrollToOptions = position;\r\n    }\r\n    if ('scrollBehavior' in document.documentElement.style)\r\n        window.scrollTo(scrollToOptions);\r\n    else {\r\n        window.scrollTo(scrollToOptions.left != null ? scrollToOptions.left : window.pageXOffset, scrollToOptions.top != null ? scrollToOptions.top : window.pageYOffset);\r\n    }\r\n}\r\nfunction getScrollKey(path, delta) {\r\n    const position = history.state ? history.state.position - delta : -1;\r\n    return position + path;\r\n}\r\nconst scrollPositions = new Map();\r\nfunction saveScrollPosition(key, scrollPosition) {\r\n    scrollPositions.set(key, scrollPosition);\r\n}\r\nfunction getSavedScrollPosition(key) {\r\n    const scroll = scrollPositions.get(key);\r\n    // consume it so it's not used again\r\n    scrollPositions.delete(key);\r\n    return scroll;\r\n}\r\n// TODO: RFC about how to save scroll position\r\n/**\r\n * ScrollBehavior instance used by the router to compute and restore the scroll\r\n * position when navigating.\r\n */\r\n// export interface ScrollHandler<ScrollPositionEntry extends HistoryStateValue, ScrollPosition extends ScrollPositionEntry> {\r\n//   // returns a scroll position that can be saved in history\r\n//   compute(): ScrollPositionEntry\r\n//   // can take an extended ScrollPositionEntry\r\n//   scroll(position: ScrollPosition): void\r\n// }\r\n// export const scrollHandler: ScrollHandler<ScrollPosition> = {\r\n//   compute: computeScroll,\r\n//   scroll: scrollToPosition,\r\n// }\n\nlet createBaseLocation = () => location.protocol + '//' + location.host;\r\n/**\r\n * Creates a normalized history location from a window.location object\r\n * @param location -\r\n */\r\nfunction createCurrentLocation(base, location) {\r\n    const { pathname, search, hash } = location;\r\n    // allows hash bases like #, /#, #/, #!, #!/, /#!/, or even /folder#end\r\n    const hashPos = base.indexOf('#');\r\n    if (hashPos > -1) {\r\n        let slicePos = hash.includes(base.slice(hashPos))\r\n            ? base.slice(hashPos).length\r\n            : 1;\r\n        let pathFromHash = hash.slice(slicePos);\r\n        // prepend the starting slash to hash so the url starts with /#\r\n        if (pathFromHash[0] !== '/')\r\n            pathFromHash = '/' + pathFromHash;\r\n        return stripBase(pathFromHash, '');\r\n    }\r\n    const path = stripBase(pathname, base);\r\n    return path + search + hash;\r\n}\r\nfunction useHistoryListeners(base, historyState, currentLocation, replace) {\r\n    let listeners = [];\r\n    let teardowns = [];\r\n    // TODO: should it be a stack? a Dict. Check if the popstate listener\r\n    // can trigger twice\r\n    let pauseState = null;\r\n    const popStateHandler = ({ state, }) => {\r\n        const to = createCurrentLocation(base, location);\r\n        const from = currentLocation.value;\r\n        const fromState = historyState.value;\r\n        let delta = 0;\r\n        if (state) {\r\n            currentLocation.value = to;\r\n            historyState.value = state;\r\n            // ignore the popstate and reset the pauseState\r\n            if (pauseState && pauseState === from) {\r\n                pauseState = null;\r\n                return;\r\n            }\r\n            delta = fromState ? state.position - fromState.position : 0;\r\n        }\r\n        else {\r\n            replace(to);\r\n        }\r\n        // console.log({ deltaFromCurrent })\r\n        // Here we could also revert the navigation by calling history.go(-delta)\r\n        // this listener will have to be adapted to not trigger again and to wait for the url\r\n        // to be updated before triggering the listeners. Some kind of validation function would also\r\n        // need to be passed to the listeners so the navigation can be accepted\r\n        // call all listeners\r\n        listeners.forEach(listener => {\r\n            listener(currentLocation.value, from, {\r\n                delta,\r\n                type: NavigationType.pop,\r\n                direction: delta\r\n                    ? delta > 0\r\n                        ? NavigationDirection.forward\r\n                        : NavigationDirection.back\r\n                    : NavigationDirection.unknown,\r\n            });\r\n        });\r\n    };\r\n    function pauseListeners() {\r\n        pauseState = currentLocation.value;\r\n    }\r\n    function listen(callback) {\r\n        // setup the listener and prepare teardown callbacks\r\n        listeners.push(callback);\r\n        const teardown = () => {\r\n            const index = listeners.indexOf(callback);\r\n            if (index > -1)\r\n                listeners.splice(index, 1);\r\n        };\r\n        teardowns.push(teardown);\r\n        return teardown;\r\n    }\r\n    function beforeUnloadListener() {\r\n        const { history } = window;\r\n        if (!history.state)\r\n            return;\r\n        history.replaceState(assign({}, history.state, { scroll: computeScrollPosition() }), '');\r\n    }\r\n    function destroy() {\r\n        for (const teardown of teardowns)\r\n            teardown();\r\n        teardowns = [];\r\n        window.removeEventListener('popstate', popStateHandler);\r\n        window.removeEventListener('beforeunload', beforeUnloadListener);\r\n    }\r\n    // setup the listeners and prepare teardown callbacks\r\n    window.addEventListener('popstate', popStateHandler);\r\n    window.addEventListener('beforeunload', beforeUnloadListener);\r\n    return {\r\n        pauseListeners,\r\n        listen,\r\n        destroy,\r\n    };\r\n}\r\n/**\r\n * Creates a state object\r\n */\r\nfunction buildState(back, current, forward, replaced = false, computeScroll = false) {\r\n    return {\r\n        back,\r\n        current,\r\n        forward,\r\n        replaced,\r\n        position: window.history.length,\r\n        scroll: computeScroll ? computeScrollPosition() : null,\r\n    };\r\n}\r\nfunction useHistoryStateNavigation(base) {\r\n    const { history, location } = window;\r\n    // private variables\r\n    let currentLocation = {\r\n        value: createCurrentLocation(base, location),\r\n    };\r\n    let historyState = { value: history.state };\r\n    // build current history entry as this is a fresh navigation\r\n    if (!historyState.value) {\r\n        changeLocation(currentLocation.value, {\r\n            back: null,\r\n            current: currentLocation.value,\r\n            forward: null,\r\n            // the length is off by one, we need to decrease it\r\n            position: history.length - 1,\r\n            replaced: true,\r\n            // don't add a scroll as the user may have an anchor and we want\r\n            // scrollBehavior to be triggered without a saved position\r\n            scroll: null,\r\n        }, true);\r\n    }\r\n    function changeLocation(to, state, replace) {\r\n        /**\r\n         * if a base tag is provided and we are on a normal domain, we have to\r\n         * respect the provided `base` attribute because pushState() will use it and\r\n         * potentially erase anything before the `#` like at\r\n         * https://github.com/vuejs/vue-router-next/issues/685 where a base of\r\n         * `/folder/#` but a base of `/` would erase the `/folder/` section. If\r\n         * there is no host, the `<base>` tag makes no sense and if there isn't a\r\n         * base tag we can just use everything after the `#`.\r\n         */\r\n        const hashIndex = base.indexOf('#');\r\n        const url = hashIndex > -1\r\n            ? (location.host && document.querySelector('base')\r\n                ? base\r\n                : base.slice(hashIndex)) + to\r\n            : createBaseLocation() + base + to;\r\n        try {\r\n            // BROWSER QUIRK\r\n            // NOTE: Safari throws a SecurityError when calling this function 100 times in 30 seconds\r\n            history[replace ? 'replaceState' : 'pushState'](state, '', url);\r\n            historyState.value = state;\r\n        }\r\n        catch (err) {\r\n            if ((process.env.NODE_ENV !== 'production')) {\r\n                warn('Error with push/replace State', err);\r\n            }\r\n            else {\r\n                console.error(err);\r\n            }\r\n            // Force the navigation, this also resets the call count\r\n            location[replace ? 'replace' : 'assign'](url);\r\n        }\r\n    }\r\n    function replace(to, data) {\r\n        const state = assign({}, history.state, buildState(historyState.value.back, \r\n        // keep back and forward entries but override current position\r\n        to, historyState.value.forward, true), data, { position: historyState.value.position });\r\n        changeLocation(to, state, true);\r\n        currentLocation.value = to;\r\n    }\r\n    function push(to, data) {\r\n        // Add to current entry the information of where we are going\r\n        // as well as saving the current position\r\n        const currentState = assign({}, \r\n        // use current history state to gracefully handle a wrong call to\r\n        // history.replaceState\r\n        // https://github.com/vuejs/vue-router-next/issues/366\r\n        historyState.value, history.state, {\r\n            forward: to,\r\n            scroll: computeScrollPosition(),\r\n        });\r\n        if ((process.env.NODE_ENV !== 'production') && !history.state) {\r\n            warn(`history.state seems to have been manually replaced without preserving the necessary values. Make sure to preserve existing history state if you are manually calling history.replaceState:\\n\\n` +\r\n                `history.replaceState(history.state, '', url)\\n\\n` +\r\n                `You can find more information at https://next.router.vuejs.org/guide/migration/#usage-of-history-state.`);\r\n        }\r\n        changeLocation(currentState.current, currentState, true);\r\n        const state = assign({}, buildState(currentLocation.value, to, null), { position: currentState.position + 1 }, data);\r\n        changeLocation(to, state, false);\r\n        currentLocation.value = to;\r\n    }\r\n    return {\r\n        location: currentLocation,\r\n        state: historyState,\r\n        push,\r\n        replace,\r\n    };\r\n}\r\n/**\r\n * Creates an HTML5 history. Most common history for single page applications.\r\n *\r\n * @param base -\r\n */\r\nfunction createWebHistory(base) {\r\n    base = normalizeBase(base);\r\n    const historyNavigation = useHistoryStateNavigation(base);\r\n    const historyListeners = useHistoryListeners(base, historyNavigation.state, historyNavigation.location, historyNavigation.replace);\r\n    function go(delta, triggerListeners = true) {\r\n        if (!triggerListeners)\r\n            historyListeners.pauseListeners();\r\n        history.go(delta);\r\n    }\r\n    const routerHistory = assign({\r\n        // it's overridden right after\r\n        location: '',\r\n        base,\r\n        go,\r\n        createHref: createHref.bind(null, base),\r\n    }, historyNavigation, historyListeners);\r\n    Object.defineProperty(routerHistory, 'location', {\r\n        enumerable: true,\r\n        get: () => historyNavigation.location.value,\r\n    });\r\n    Object.defineProperty(routerHistory, 'state', {\r\n        enumerable: true,\r\n        get: () => historyNavigation.state.value,\r\n    });\r\n    return routerHistory;\r\n}\n\n/**\r\n * Creates a in-memory based history. The main purpose of this history is to handle SSR. It starts in a special location that is nowhere.\r\n * It's up to the user to replace that location with the starter location by either calling `router.push` or `router.replace`.\r\n *\r\n * @param base - Base applied to all urls, defaults to '/'\r\n * @returns a history object that can be passed to the router constructor\r\n */\r\nfunction createMemoryHistory(base = '') {\r\n    let listeners = [];\r\n    let queue = [START];\r\n    let position = 0;\r\n    function setLocation(location) {\r\n        position++;\r\n        if (position === queue.length) {\r\n            // we are at the end, we can simply append a new entry\r\n            queue.push(location);\r\n        }\r\n        else {\r\n            // we are in the middle, we remove everything from here in the queue\r\n            queue.splice(position);\r\n            queue.push(location);\r\n        }\r\n    }\r\n    function triggerListeners(to, from, { direction, delta }) {\r\n        const info = {\r\n            direction,\r\n            delta,\r\n            type: NavigationType.pop,\r\n        };\r\n        for (let callback of listeners) {\r\n            callback(to, from, info);\r\n        }\r\n    }\r\n    const routerHistory = {\r\n        // rewritten by Object.defineProperty\r\n        location: START,\r\n        // TODO: should be kept in queue\r\n        state: {},\r\n        base,\r\n        createHref: createHref.bind(null, base),\r\n        replace(to) {\r\n            // remove current entry and decrement position\r\n            queue.splice(position--, 1);\r\n            setLocation(to);\r\n        },\r\n        push(to, data) {\r\n            setLocation(to);\r\n        },\r\n        listen(callback) {\r\n            listeners.push(callback);\r\n            return () => {\r\n                const index = listeners.indexOf(callback);\r\n                if (index > -1)\r\n                    listeners.splice(index, 1);\r\n            };\r\n        },\r\n        destroy() {\r\n            listeners = [];\r\n            queue = [START];\r\n            position = 0;\r\n        },\r\n        go(delta, shouldTrigger = true) {\r\n            const from = this.location;\r\n            const direction = \r\n            // we are considering delta === 0 going forward, but in abstract mode\r\n            // using 0 for the delta doesn't make sense like it does in html5 where\r\n            // it reloads the page\r\n            delta < 0 ? NavigationDirection.back : NavigationDirection.forward;\r\n            position = Math.max(0, Math.min(position + delta, queue.length - 1));\r\n            if (shouldTrigger) {\r\n                triggerListeners(this.location, from, {\r\n                    direction,\r\n                    delta,\r\n                });\r\n            }\r\n        },\r\n    };\r\n    Object.defineProperty(routerHistory, 'location', {\r\n        enumerable: true,\r\n        get: () => queue[position],\r\n    });\r\n    return routerHistory;\r\n}\n\n/**\r\n * Creates a hash history. Useful for web applications with no host (e.g.\r\n * `file://`) or when configuring a server to handle any URL is not possible.\r\n *\r\n * @param base - optional base to provide. Defaults to `location.pathname +\r\n * location.search` If there is a `<base>` tag in the `head`, its value will be\r\n * ignored in favor of this parameter **but note it affects all the\r\n * history.pushState() calls**, meaning that if you use a `<base>` tag, it's\r\n * `href` value **has to match this parameter** (ignoring anything after the\r\n * `#`).\r\n *\r\n * @example\r\n * ```js\r\n * // at https://example.com/folder\r\n * createWebHashHistory() // gives a url of `https://example.com/folder#`\r\n * createWebHashHistory('/folder/') // gives a url of `https://example.com/folder/#`\r\n * // if the `#` is provided in the base, it won't be added by `createWebHashHistory`\r\n * createWebHashHistory('/folder/#/app/') // gives a url of `https://example.com/folder/#/app/`\r\n * // you should avoid doing this because it changes the original url and breaks copying urls\r\n * createWebHashHistory('/other-folder/') // gives a url of `https://example.com/other-folder/#`\r\n *\r\n * // at file:///usr/etc/folder/index.html\r\n * // for locations with no `host`, the base is ignored\r\n * createWebHashHistory('/iAmIgnored') // gives a url of `file:///usr/etc/folder/index.html#`\r\n * ```\r\n */\r\nfunction createWebHashHistory(base) {\r\n    // Make sure this implementation is fine in terms of encoding, specially for IE11\r\n    // for `file://`, directly use the pathname and ignore the base\r\n    // location.pathname contains an initial `/` even at the root: `https://example.com`\r\n    base = location.host ? base || location.pathname + location.search : '';\r\n    // allow the user to provide a `#` in the middle: `/base/#/app`\r\n    if (base.indexOf('#') < 0)\r\n        base += '#';\r\n    if ((process.env.NODE_ENV !== 'production') && !base.endsWith('#/') && !base.endsWith('#')) {\r\n        warn(`A hash base must end with a \"#\":\\n\"${base}\" should be \"${base.replace(/#.*$/, '#')}\".`);\r\n    }\r\n    return createWebHistory(base);\r\n}\n\nfunction isRouteLocation(route) {\r\n    return typeof route === 'string' || (route && typeof route === 'object');\r\n}\r\nfunction isRouteName(name) {\r\n    return typeof name === 'string' || typeof name === 'symbol';\r\n}\n\n/**\r\n * Initial route location where the router is. Can be used in navigation guards\r\n * to differentiate the initial navigation.\r\n *\r\n * @example\r\n * ```js\r\n * import { START_LOCATION } from 'vue-router'\r\n *\r\n * router.beforeEach((to, from) => {\r\n *   if (from === START_LOCATION) {\r\n *     // initial navigation\r\n *   }\r\n * })\r\n * ```\r\n */\r\nconst START_LOCATION_NORMALIZED = {\r\n    path: '/',\r\n    name: undefined,\r\n    params: {},\r\n    query: {},\r\n    hash: '',\r\n    fullPath: '/',\r\n    matched: [],\r\n    meta: {},\r\n    redirectedFrom: undefined,\r\n};\n\nconst NavigationFailureSymbol = /*#__PURE__*/ PolySymbol((process.env.NODE_ENV !== 'production') ? 'navigation failure' : 'nf');\r\n/**\r\n * Enumeration with all possible types for navigation failures. Can be passed to\r\n * {@link isNavigationFailure} to check for specific failures.\r\n */\r\nvar NavigationFailureType;\r\n(function (NavigationFailureType) {\r\n    /**\r\n     * An aborted navigation is a navigation that failed because a navigation\r\n     * guard returned `false` or called `next(false)`\r\n     */\r\n    NavigationFailureType[NavigationFailureType[\"aborted\"] = 4] = \"aborted\";\r\n    /**\r\n     * A cancelled navigation is a navigation that failed because a more recent\r\n     * navigation finished started (not necessarily finished).\r\n     */\r\n    NavigationFailureType[NavigationFailureType[\"cancelled\"] = 8] = \"cancelled\";\r\n    /**\r\n     * A duplicated navigation is a navigation that failed because it was\r\n     * initiated while already being at the exact same location.\r\n     */\r\n    NavigationFailureType[NavigationFailureType[\"duplicated\"] = 16] = \"duplicated\";\r\n})(NavigationFailureType || (NavigationFailureType = {}));\r\n// DEV only debug messages\r\nconst ErrorTypeMessages = {\r\n    [1 /* MATCHER_NOT_FOUND */]({ location, currentLocation }) {\r\n        return `No match for\\n ${JSON.stringify(location)}${currentLocation\r\n            ? '\\nwhile being at\\n' + JSON.stringify(currentLocation)\r\n            : ''}`;\r\n    },\r\n    [2 /* NAVIGATION_GUARD_REDIRECT */]({ from, to, }) {\r\n        return `Redirected from \"${from.fullPath}\" to \"${stringifyRoute(to)}\" via a navigation guard.`;\r\n    },\r\n    [4 /* NAVIGATION_ABORTED */]({ from, to }) {\r\n        return `Navigation aborted from \"${from.fullPath}\" to \"${to.fullPath}\" via a navigation guard.`;\r\n    },\r\n    [8 /* NAVIGATION_CANCELLED */]({ from, to }) {\r\n        return `Navigation cancelled from \"${from.fullPath}\" to \"${to.fullPath}\" with a new navigation.`;\r\n    },\r\n    [16 /* NAVIGATION_DUPLICATED */]({ from, to }) {\r\n        return `Avoided redundant navigation to current location: \"${from.fullPath}\".`;\r\n    },\r\n};\r\nfunction createRouterError(type, params) {\r\n    // keep full error messages in cjs versions\r\n    if ((process.env.NODE_ENV !== 'production') || !true) {\r\n        return assign(new Error(ErrorTypeMessages[type](params)), {\r\n            type,\r\n            [NavigationFailureSymbol]: true,\r\n        }, params);\r\n    }\r\n    else {\r\n        return assign(new Error(), {\r\n            type,\r\n            [NavigationFailureSymbol]: true,\r\n        }, params);\r\n    }\r\n}\r\nfunction isNavigationFailure(error, type) {\r\n    return (error instanceof Error &&\r\n        NavigationFailureSymbol in error &&\r\n        (type == null || !!(error.type & type)));\r\n}\r\nconst propertiesToLog = ['params', 'query', 'hash'];\r\nfunction stringifyRoute(to) {\r\n    if (typeof to === 'string')\r\n        return to;\r\n    if ('path' in to)\r\n        return to.path;\r\n    const location = {};\r\n    for (const key of propertiesToLog) {\r\n        if (key in to)\r\n            location[key] = to[key];\r\n    }\r\n    return JSON.stringify(location, null, 2);\r\n}\n\n// default pattern for a param: non greedy everything but /\r\nconst BASE_PARAM_PATTERN = '[^/]+?';\r\nconst BASE_PATH_PARSER_OPTIONS = {\r\n    sensitive: false,\r\n    strict: false,\r\n    start: true,\r\n    end: true,\r\n};\r\n// Special Regex characters that must be escaped in static tokens\r\nconst REGEX_CHARS_RE = /[.+*?^${}()[\\]/\\\\]/g;\r\n/**\r\n * Creates a path parser from an array of Segments (a segment is an array of Tokens)\r\n *\r\n * @param segments - array of segments returned by tokenizePath\r\n * @param extraOptions - optional options for the regexp\r\n * @returns a PathParser\r\n */\r\nfunction tokensToParser(segments, extraOptions) {\r\n    const options = assign({}, BASE_PATH_PARSER_OPTIONS, extraOptions);\r\n    // the amount of scores is the same as the length of segments except for the root segment \"/\"\r\n    let score = [];\r\n    // the regexp as a string\r\n    let pattern = options.start ? '^' : '';\r\n    // extracted keys\r\n    const keys = [];\r\n    for (const segment of segments) {\r\n        // the root segment needs special treatment\r\n        const segmentScores = segment.length ? [] : [90 /* Root */];\r\n        // allow trailing slash\r\n        if (options.strict && !segment.length)\r\n            pattern += '/';\r\n        for (let tokenIndex = 0; tokenIndex < segment.length; tokenIndex++) {\r\n            const token = segment[tokenIndex];\r\n            // resets the score if we are inside a sub segment /:a-other-:b\r\n            let subSegmentScore = 40 /* Segment */ +\r\n                (options.sensitive ? 0.25 /* BonusCaseSensitive */ : 0);\r\n            if (token.type === 0 /* Static */) {\r\n                // prepend the slash if we are starting a new segment\r\n                if (!tokenIndex)\r\n                    pattern += '/';\r\n                pattern += token.value.replace(REGEX_CHARS_RE, '\\\\$&');\r\n                subSegmentScore += 40 /* Static */;\r\n            }\r\n            else if (token.type === 1 /* Param */) {\r\n                const { value, repeatable, optional, regexp } = token;\r\n                keys.push({\r\n                    name: value,\r\n                    repeatable,\r\n                    optional,\r\n                });\r\n                const re = regexp ? regexp : BASE_PARAM_PATTERN;\r\n                // the user provided a custom regexp /:id(\\\\d+)\r\n                if (re !== BASE_PARAM_PATTERN) {\r\n                    subSegmentScore += 10 /* BonusCustomRegExp */;\r\n                    // make sure the regexp is valid before using it\r\n                    try {\r\n                        new RegExp(`(${re})`);\r\n                    }\r\n                    catch (err) {\r\n                        throw new Error(`Invalid custom RegExp for param \"${value}\" (${re}): ` +\r\n                            err.message);\r\n                    }\r\n                }\r\n                // when we repeat we must take care of the repeating leading slash\r\n                let subPattern = repeatable ? `((?:${re})(?:/(?:${re}))*)` : `(${re})`;\r\n                // prepend the slash if we are starting a new segment\r\n                if (!tokenIndex)\r\n                    subPattern =\r\n                        // avoid an optional / if there are more segments e.g. /:p?-static\r\n                        // or /:p?-:p2\r\n                        optional && segment.length < 2\r\n                            ? `(?:/${subPattern})`\r\n                            : '/' + subPattern;\r\n                if (optional)\r\n                    subPattern += '?';\r\n                pattern += subPattern;\r\n                subSegmentScore += 20 /* Dynamic */;\r\n                if (optional)\r\n                    subSegmentScore += -8 /* BonusOptional */;\r\n                if (repeatable)\r\n                    subSegmentScore += -20 /* BonusRepeatable */;\r\n                if (re === '.*')\r\n                    subSegmentScore += -50 /* BonusWildcard */;\r\n            }\r\n            segmentScores.push(subSegmentScore);\r\n        }\r\n        // an empty array like /home/ -> [[{home}], []]\r\n        // if (!segment.length) pattern += '/'\r\n        score.push(segmentScores);\r\n    }\r\n    // only apply the strict bonus to the last score\r\n    if (options.strict && options.end) {\r\n        const i = score.length - 1;\r\n        score[i][score[i].length - 1] += 0.7000000000000001 /* BonusStrict */;\r\n    }\r\n    // TODO: dev only warn double trailing slash\r\n    if (!options.strict)\r\n        pattern += '/?';\r\n    if (options.end)\r\n        pattern += '$';\r\n    // allow paths like /dynamic to only match dynamic or dynamic/... but not dynamic_something_else\r\n    else if (options.strict)\r\n        pattern += '(?:/|$)';\r\n    const re = new RegExp(pattern, options.sensitive ? '' : 'i');\r\n    function parse(path) {\r\n        const match = path.match(re);\r\n        const params = {};\r\n        if (!match)\r\n            return null;\r\n        for (let i = 1; i < match.length; i++) {\r\n            const value = match[i] || '';\r\n            const key = keys[i - 1];\r\n            params[key.name] = value && key.repeatable ? value.split('/') : value;\r\n        }\r\n        return params;\r\n    }\r\n    function stringify(params) {\r\n        let path = '';\r\n        // for optional parameters to allow to be empty\r\n        let avoidDuplicatedSlash = false;\r\n        for (const segment of segments) {\r\n            if (!avoidDuplicatedSlash || !path.endsWith('/'))\r\n                path += '/';\r\n            avoidDuplicatedSlash = false;\r\n            for (const token of segment) {\r\n                if (token.type === 0 /* Static */) {\r\n                    path += token.value;\r\n                }\r\n                else if (token.type === 1 /* Param */) {\r\n                    const { value, repeatable, optional } = token;\r\n                    const param = value in params ? params[value] : '';\r\n                    if (Array.isArray(param) && !repeatable)\r\n                        throw new Error(`Provided param \"${value}\" is an array but it is not repeatable (* or + modifiers)`);\r\n                    const text = Array.isArray(param) ? param.join('/') : param;\r\n                    if (!text) {\r\n                        if (optional) {\r\n                            // if we have more than one optional param like /:a?-static we\r\n                            // don't need to care about the optional param\r\n                            if (segment.length < 2) {\r\n                                // remove the last slash as we could be at the end\r\n                                if (path.endsWith('/'))\r\n                                    path = path.slice(0, -1);\r\n                                // do not append a slash on the next iteration\r\n                                else\r\n                                    avoidDuplicatedSlash = true;\r\n                            }\r\n                        }\r\n                        else\r\n                            throw new Error(`Missing required param \"${value}\"`);\r\n                    }\r\n                    path += text;\r\n                }\r\n            }\r\n        }\r\n        return path;\r\n    }\r\n    return {\r\n        re,\r\n        score,\r\n        keys,\r\n        parse,\r\n        stringify,\r\n    };\r\n}\r\n/**\r\n * Compares an array of numbers as used in PathParser.score and returns a\r\n * number. This function can be used to `sort` an array\r\n * @param a - first array of numbers\r\n * @param b - second array of numbers\r\n * @returns 0 if both are equal, < 0 if a should be sorted first, > 0 if b\r\n * should be sorted first\r\n */\r\nfunction compareScoreArray(a, b) {\r\n    let i = 0;\r\n    while (i < a.length && i < b.length) {\r\n        const diff = b[i] - a[i];\r\n        // only keep going if diff === 0\r\n        if (diff)\r\n            return diff;\r\n        i++;\r\n    }\r\n    // if the last subsegment was Static, the shorter segments should be sorted first\r\n    // otherwise sort the longest segment first\r\n    if (a.length < b.length) {\r\n        return a.length === 1 && a[0] === 40 /* Static */ + 40 /* Segment */\r\n            ? -1\r\n            : 1;\r\n    }\r\n    else if (a.length > b.length) {\r\n        return b.length === 1 && b[0] === 40 /* Static */ + 40 /* Segment */\r\n            ? 1\r\n            : -1;\r\n    }\r\n    return 0;\r\n}\r\n/**\r\n * Compare function that can be used with `sort` to sort an array of PathParser\r\n * @param a - first PathParser\r\n * @param b - second PathParser\r\n * @returns 0 if both are equal, < 0 if a should be sorted first, > 0 if b\r\n */\r\nfunction comparePathParserScore(a, b) {\r\n    let i = 0;\r\n    const aScore = a.score;\r\n    const bScore = b.score;\r\n    while (i < aScore.length && i < bScore.length) {\r\n        const comp = compareScoreArray(aScore[i], bScore[i]);\r\n        // do not return if both are equal\r\n        if (comp)\r\n            return comp;\r\n        i++;\r\n    }\r\n    // if a and b share the same score entries but b has more, sort b first\r\n    return bScore.length - aScore.length;\r\n    // this is the ternary version\r\n    // return aScore.length < bScore.length\r\n    //   ? 1\r\n    //   : aScore.length > bScore.length\r\n    //   ? -1\r\n    //   : 0\r\n}\n\nconst ROOT_TOKEN = {\r\n    type: 0 /* Static */,\r\n    value: '',\r\n};\r\nconst VALID_PARAM_RE = /[a-zA-Z0-9_]/;\r\n// After some profiling, the cache seems to be unnecessary because tokenizePath\r\n// (the slowest part of adding a route) is very fast\r\n// const tokenCache = new Map<string, Token[][]>()\r\nfunction tokenizePath(path) {\r\n    if (!path)\r\n        return [[]];\r\n    if (path === '/')\r\n        return [[ROOT_TOKEN]];\r\n    if (!path.startsWith('/')) {\r\n        throw new Error((process.env.NODE_ENV !== 'production')\r\n            ? `Route paths should start with a \"/\": \"${path}\" should be \"/${path}\".`\r\n            : `Invalid path \"${path}\"`);\r\n    }\r\n    // if (tokenCache.has(path)) return tokenCache.get(path)!\r\n    function crash(message) {\r\n        throw new Error(`ERR (${state})/\"${buffer}\": ${message}`);\r\n    }\r\n    let state = 0 /* Static */;\r\n    let previousState = state;\r\n    const tokens = [];\r\n    // the segment will always be valid because we get into the initial state\r\n    // with the leading /\r\n    let segment;\r\n    function finalizeSegment() {\r\n        if (segment)\r\n            tokens.push(segment);\r\n        segment = [];\r\n    }\r\n    // index on the path\r\n    let i = 0;\r\n    // char at index\r\n    let char;\r\n    // buffer of the value read\r\n    let buffer = '';\r\n    // custom regexp for a param\r\n    let customRe = '';\r\n    function consumeBuffer() {\r\n        if (!buffer)\r\n            return;\r\n        if (state === 0 /* Static */) {\r\n            segment.push({\r\n                type: 0 /* Static */,\r\n                value: buffer,\r\n            });\r\n        }\r\n        else if (state === 1 /* Param */ ||\r\n            state === 2 /* ParamRegExp */ ||\r\n            state === 3 /* ParamRegExpEnd */) {\r\n            if (segment.length > 1 && (char === '*' || char === '+'))\r\n                crash(`A repeatable param (${buffer}) must be alone in its segment. eg: '/:ids+.`);\r\n            segment.push({\r\n                type: 1 /* Param */,\r\n                value: buffer,\r\n                regexp: customRe,\r\n                repeatable: char === '*' || char === '+',\r\n                optional: char === '*' || char === '?',\r\n            });\r\n        }\r\n        else {\r\n            crash('Invalid state to consume buffer');\r\n        }\r\n        buffer = '';\r\n    }\r\n    function addCharToBuffer() {\r\n        buffer += char;\r\n    }\r\n    while (i < path.length) {\r\n        char = path[i++];\r\n        if (char === '\\\\' && state !== 2 /* ParamRegExp */) {\r\n            previousState = state;\r\n            state = 4 /* EscapeNext */;\r\n            continue;\r\n        }\r\n        switch (state) {\r\n            case 0 /* Static */:\r\n                if (char === '/') {\r\n                    if (buffer) {\r\n                        consumeBuffer();\r\n                    }\r\n                    finalizeSegment();\r\n                }\r\n                else if (char === ':') {\r\n                    consumeBuffer();\r\n                    state = 1 /* Param */;\r\n                }\r\n                else {\r\n                    addCharToBuffer();\r\n                }\r\n                break;\r\n            case 4 /* EscapeNext */:\r\n                addCharToBuffer();\r\n                state = previousState;\r\n                break;\r\n            case 1 /* Param */:\r\n                if (char === '(') {\r\n                    state = 2 /* ParamRegExp */;\r\n                }\r\n                else if (VALID_PARAM_RE.test(char)) {\r\n                    addCharToBuffer();\r\n                }\r\n                else {\r\n                    consumeBuffer();\r\n                    state = 0 /* Static */;\r\n                    // go back one character if we were not modifying\r\n                    if (char !== '*' && char !== '?' && char !== '+')\r\n                        i--;\r\n                }\r\n                break;\r\n            case 2 /* ParamRegExp */:\r\n                // TODO: is it worth handling nested regexp? like :p(?:prefix_([^/]+)_suffix)\r\n                // it already works by escaping the closing )\r\n                // https://paths.esm.dev/?p=AAMeJbiAwQEcDKbAoAAkP60PG2R6QAvgNaA6AFACM2ABuQBB#\r\n                // is this really something people need since you can also write\r\n                // /prefix_:p()_suffix\r\n                if (char === ')') {\r\n                    // handle the escaped )\r\n                    if (customRe[customRe.length - 1] == '\\\\')\r\n                        customRe = customRe.slice(0, -1) + char;\r\n                    else\r\n                        state = 3 /* ParamRegExpEnd */;\r\n                }\r\n                else {\r\n                    customRe += char;\r\n                }\r\n                break;\r\n            case 3 /* ParamRegExpEnd */:\r\n                // same as finalizing a param\r\n                consumeBuffer();\r\n                state = 0 /* Static */;\r\n                // go back one character if we were not modifying\r\n                if (char !== '*' && char !== '?' && char !== '+')\r\n                    i--;\r\n                customRe = '';\r\n                break;\r\n            default:\r\n                crash('Unknown state');\r\n                break;\r\n        }\r\n    }\r\n    if (state === 2 /* ParamRegExp */)\r\n        crash(`Unfinished custom RegExp for param \"${buffer}\"`);\r\n    consumeBuffer();\r\n    finalizeSegment();\r\n    // tokenCache.set(path, tokens)\r\n    return tokens;\r\n}\n\nfunction createRouteRecordMatcher(record, parent, options) {\r\n    const parser = tokensToParser(tokenizePath(record.path), options);\r\n    // warn against params with the same name\r\n    if ((process.env.NODE_ENV !== 'production')) {\r\n        const existingKeys = new Set();\r\n        for (const key of parser.keys) {\r\n            if (existingKeys.has(key.name))\r\n                warn(`Found duplicated params with name \"${key.name}\" for path \"${record.path}\". Only the last one will be available on \"$route.params\".`);\r\n            existingKeys.add(key.name);\r\n        }\r\n    }\r\n    const matcher = assign(parser, {\r\n        record,\r\n        parent,\r\n        // these needs to be populated by the parent\r\n        children: [],\r\n        alias: [],\r\n    });\r\n    if (parent) {\r\n        // both are aliases or both are not aliases\r\n        // we don't want to mix them because the order is used when\r\n        // passing originalRecord in Matcher.addRoute\r\n        if (!matcher.record.aliasOf === !parent.record.aliasOf)\r\n            parent.children.push(matcher);\r\n    }\r\n    return matcher;\r\n}\n\n/**\r\n * Creates a Router Matcher.\r\n *\r\n * @internal\r\n * @param routes - array of initial routes\r\n * @param globalOptions - global route options\r\n */\r\nfunction createRouterMatcher(routes, globalOptions) {\r\n    // normalized ordered array of matchers\r\n    const matchers = [];\r\n    const matcherMap = new Map();\r\n    globalOptions = mergeOptions({ strict: false, end: true, sensitive: false }, globalOptions);\r\n    function getRecordMatcher(name) {\r\n        return matcherMap.get(name);\r\n    }\r\n    function addRoute(record, parent, originalRecord) {\r\n        // used later on to remove by name\r\n        let isRootAdd = !originalRecord;\r\n        let mainNormalizedRecord = normalizeRouteRecord(record);\r\n        // we might be the child of an alias\r\n        mainNormalizedRecord.aliasOf = originalRecord && originalRecord.record;\r\n        const options = mergeOptions(globalOptions, record);\r\n        // generate an array of records to correctly handle aliases\r\n        const normalizedRecords = [\r\n            mainNormalizedRecord,\r\n        ];\r\n        if ('alias' in record) {\r\n            const aliases = typeof record.alias === 'string' ? [record.alias] : record.alias;\r\n            for (const alias of aliases) {\r\n                normalizedRecords.push(assign({}, mainNormalizedRecord, {\r\n                    // this allows us to hold a copy of the `components` option\r\n                    // so that async components cache is hold on the original record\r\n                    components: originalRecord\r\n                        ? originalRecord.record.components\r\n                        : mainNormalizedRecord.components,\r\n                    path: alias,\r\n                    // we might be the child of an alias\r\n                    aliasOf: originalRecord\r\n                        ? originalRecord.record\r\n                        : mainNormalizedRecord,\r\n                    // the aliases are always of the same kind as the original since they\r\n                    // are defined on the same record\r\n                }));\r\n            }\r\n        }\r\n        let matcher;\r\n        let originalMatcher;\r\n        for (const normalizedRecord of normalizedRecords) {\r\n            let { path } = normalizedRecord;\r\n            // Build up the path for nested routes if the child isn't an absolute\r\n            // route. Only add the / delimiter if the child path isn't empty and if the\r\n            // parent path doesn't have a trailing slash\r\n            if (parent && path[0] !== '/') {\r\n                let parentPath = parent.record.path;\r\n                let connectingSlash = parentPath[parentPath.length - 1] === '/' ? '' : '/';\r\n                normalizedRecord.path =\r\n                    parent.record.path + (path && connectingSlash + path);\r\n            }\r\n            if ((process.env.NODE_ENV !== 'production') && normalizedRecord.path === '*') {\r\n                throw new Error('Catch all routes (\"*\") must now be defined using a param with a custom regexp.\\n' +\r\n                    'See more at https://next.router.vuejs.org/guide/migration/#removed-star-or-catch-all-routes.');\r\n            }\r\n            // create the object before hand so it can be passed to children\r\n            matcher = createRouteRecordMatcher(normalizedRecord, parent, options);\r\n            if ((process.env.NODE_ENV !== 'production') && parent && path[0] === '/')\r\n                checkMissingParamsInAbsolutePath(matcher, parent);\r\n            // if we are an alias we must tell the original record that we exist\r\n            // so we can be removed\r\n            if (originalRecord) {\r\n                originalRecord.alias.push(matcher);\r\n                if ((process.env.NODE_ENV !== 'production')) {\r\n                    checkSameParams(originalRecord, matcher);\r\n                }\r\n            }\r\n            else {\r\n                // otherwise, the first record is the original and others are aliases\r\n                originalMatcher = originalMatcher || matcher;\r\n                if (originalMatcher !== matcher)\r\n                    originalMatcher.alias.push(matcher);\r\n                // remove the route if named and only for the top record (avoid in nested calls)\r\n                // this works because the original record is the first one\r\n                if (isRootAdd && record.name && !isAliasRecord(matcher))\r\n                    removeRoute(record.name);\r\n            }\r\n            if ('children' in mainNormalizedRecord) {\r\n                let children = mainNormalizedRecord.children;\r\n                for (let i = 0; i < children.length; i++) {\r\n                    addRoute(children[i], matcher, originalRecord && originalRecord.children[i]);\r\n                }\r\n            }\r\n            // if there was no original record, then the first one was not an alias and all\r\n            // other alias (if any) need to reference this record when adding children\r\n            originalRecord = originalRecord || matcher;\r\n            // TODO: add normalized records for more flexibility\r\n            // if (parent && isAliasRecord(originalRecord)) {\r\n            //   parent.children.push(originalRecord)\r\n            // }\r\n            insertMatcher(matcher);\r\n        }\r\n        return originalMatcher\r\n            ? () => {\r\n                // since other matchers are aliases, they should be removed by the original matcher\r\n                removeRoute(originalMatcher);\r\n            }\r\n            : noop;\r\n    }\r\n    function removeRoute(matcherRef) {\r\n        if (isRouteName(matcherRef)) {\r\n            const matcher = matcherMap.get(matcherRef);\r\n            if (matcher) {\r\n                matcherMap.delete(matcherRef);\r\n                matchers.splice(matchers.indexOf(matcher), 1);\r\n                matcher.children.forEach(removeRoute);\r\n                matcher.alias.forEach(removeRoute);\r\n            }\r\n        }\r\n        else {\r\n            let index = matchers.indexOf(matcherRef);\r\n            if (index > -1) {\r\n                matchers.splice(index, 1);\r\n                if (matcherRef.record.name)\r\n                    matcherMap.delete(matcherRef.record.name);\r\n                matcherRef.children.forEach(removeRoute);\r\n                matcherRef.alias.forEach(removeRoute);\r\n            }\r\n        }\r\n    }\r\n    function getRoutes() {\r\n        return matchers;\r\n    }\r\n    function insertMatcher(matcher) {\r\n        let i = 0;\r\n        // console.log('i is', { i })\r\n        while (i < matchers.length &&\r\n            comparePathParserScore(matcher, matchers[i]) >= 0)\r\n            i++;\r\n        // console.log('END i is', { i })\r\n        // while (i < matchers.length && matcher.score <= matchers[i].score) i++\r\n        matchers.splice(i, 0, matcher);\r\n        // only add the original record to the name map\r\n        if (matcher.record.name && !isAliasRecord(matcher))\r\n            matcherMap.set(matcher.record.name, matcher);\r\n    }\r\n    function resolve(location, currentLocation) {\r\n        let matcher;\r\n        let params = {};\r\n        let path;\r\n        let name;\r\n        if ('name' in location && location.name) {\r\n            matcher = matcherMap.get(location.name);\r\n            if (!matcher)\r\n                throw createRouterError(1 /* MATCHER_NOT_FOUND */, {\r\n                    location,\r\n                });\r\n            name = matcher.record.name;\r\n            params = assign(\r\n            // paramsFromLocation is a new object\r\n            paramsFromLocation(currentLocation.params, \r\n            // only keep params that exist in the resolved location\r\n            // TODO: only keep optional params coming from a parent record\r\n            matcher.keys.filter(k => !k.optional).map(k => k.name)), location.params);\r\n            // throws if cannot be stringified\r\n            path = matcher.stringify(params);\r\n        }\r\n        else if ('path' in location) {\r\n            // no need to resolve the path with the matcher as it was provided\r\n            // this also allows the user to control the encoding\r\n            path = location.path;\r\n            if ((process.env.NODE_ENV !== 'production') && !path.startsWith('/')) {\r\n                warn(`The Matcher cannot resolve relative paths but received \"${path}\". Unless you directly called \\`matcher.resolve(\"${path}\")\\`, this is probably a bug in vue-router. Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/vue-router-next.`);\r\n            }\r\n            matcher = matchers.find(m => m.re.test(path));\r\n            // matcher should have a value after the loop\r\n            if (matcher) {\r\n                // TODO: dev warning of unused params if provided\r\n                // we know the matcher works because we tested the regexp\r\n                params = matcher.parse(path);\r\n                name = matcher.record.name;\r\n            }\r\n            // location is a relative path\r\n        }\r\n        else {\r\n            // match by name or path of current route\r\n            matcher = currentLocation.name\r\n                ? matcherMap.get(currentLocation.name)\r\n                : matchers.find(m => m.re.test(currentLocation.path));\r\n            if (!matcher)\r\n                throw createRouterError(1 /* MATCHER_NOT_FOUND */, {\r\n                    location,\r\n                    currentLocation,\r\n                });\r\n            name = matcher.record.name;\r\n            // since we are navigating to the same location, we don't need to pick the\r\n            // params like when `name` is provided\r\n            params = assign({}, currentLocation.params, location.params);\r\n            path = matcher.stringify(params);\r\n        }\r\n        const matched = [];\r\n        let parentMatcher = matcher;\r\n        while (parentMatcher) {\r\n            // reversed order so parents are at the beginning\r\n            matched.unshift(parentMatcher.record);\r\n            parentMatcher = parentMatcher.parent;\r\n        }\r\n        return {\r\n            name,\r\n            path,\r\n            params,\r\n            matched,\r\n            meta: mergeMetaFields(matched),\r\n        };\r\n    }\r\n    // add initial routes\r\n    routes.forEach(route => addRoute(route));\r\n    return { addRoute, resolve, removeRoute, getRoutes, getRecordMatcher };\r\n}\r\nfunction paramsFromLocation(params, keys) {\r\n    let newParams = {};\r\n    for (let key of keys) {\r\n        if (key in params)\r\n            newParams[key] = params[key];\r\n    }\r\n    return newParams;\r\n}\r\n/**\r\n * Normalizes a RouteRecordRaw. Creates a copy\r\n *\r\n * @param record\r\n * @returns the normalized version\r\n */\r\nfunction normalizeRouteRecord(record) {\r\n    return {\r\n        path: record.path,\r\n        redirect: record.redirect,\r\n        name: record.name,\r\n        meta: record.meta || {},\r\n        aliasOf: undefined,\r\n        beforeEnter: record.beforeEnter,\r\n        props: normalizeRecordProps(record),\r\n        children: record.children || [],\r\n        instances: {},\r\n        leaveGuards: new Set(),\r\n        updateGuards: new Set(),\r\n        enterCallbacks: {},\r\n        components: 'components' in record\r\n            ? record.components || {}\r\n            : { default: record.component },\r\n    };\r\n}\r\n/**\r\n * Normalize the optional `props` in a record to always be an object similar to\r\n * components. Also accept a boolean for components.\r\n * @param record\r\n */\r\nfunction normalizeRecordProps(record) {\r\n    const propsObject = {};\r\n    // props does not exist on redirect records but we can set false directly\r\n    const props = record.props || false;\r\n    if ('component' in record) {\r\n        propsObject.default = props;\r\n    }\r\n    else {\r\n        // NOTE: we could also allow a function to be applied to every component.\r\n        // Would need user feedback for use cases\r\n        for (let name in record.components)\r\n            propsObject[name] = typeof props === 'boolean' ? props : props[name];\r\n    }\r\n    return propsObject;\r\n}\r\n/**\r\n * Checks if a record or any of its parent is an alias\r\n * @param record\r\n */\r\nfunction isAliasRecord(record) {\r\n    while (record) {\r\n        if (record.record.aliasOf)\r\n            return true;\r\n        record = record.parent;\r\n    }\r\n    return false;\r\n}\r\n/**\r\n * Merge meta fields of an array of records\r\n *\r\n * @param matched - array of matched records\r\n */\r\nfunction mergeMetaFields(matched) {\r\n    return matched.reduce((meta, record) => assign(meta, record.meta), {});\r\n}\r\nfunction mergeOptions(defaults, partialOptions) {\r\n    let options = {};\r\n    for (let key in defaults) {\r\n        options[key] =\r\n            key in partialOptions ? partialOptions[key] : defaults[key];\r\n    }\r\n    return options;\r\n}\r\nfunction isSameParam(a, b) {\r\n    return (a.name === b.name &&\r\n        a.optional === b.optional &&\r\n        a.repeatable === b.repeatable);\r\n}\r\n/**\r\n * Check if a path and its alias have the same required params\r\n *\r\n * @param a - original record\r\n * @param b - alias record\r\n */\r\nfunction checkSameParams(a, b) {\r\n    for (let key of a.keys) {\r\n        if (!key.optional && !b.keys.find(isSameParam.bind(null, key)))\r\n            return warn(`Alias \"${b.record.path}\" and the original record: \"${a.record.path}\" should have the exact same param named \"${key.name}\"`);\r\n    }\r\n    for (let key of b.keys) {\r\n        if (!key.optional && !a.keys.find(isSameParam.bind(null, key)))\r\n            return warn(`Alias \"${b.record.path}\" and the original record: \"${a.record.path}\" should have the exact same param named \"${key.name}\"`);\r\n    }\r\n}\r\nfunction checkMissingParamsInAbsolutePath(record, parent) {\r\n    for (let key of parent.keys) {\r\n        if (!record.keys.find(isSameParam.bind(null, key)))\r\n            return warn(`Absolute path \"${record.record.path}\" should have the exact same param named \"${key.name}\" as its parent \"${parent.record.path}\".`);\r\n    }\r\n}\n\n/**\r\n * Encoding Rules ␣ = Space Path: ␣ \" < > # ? { } Query: ␣ \" < > # & = Hash: ␣ \"\r\n * < > `\r\n *\r\n * On top of that, the RFC3986 (https://tools.ietf.org/html/rfc3986#section-2.2)\r\n * defines some extra characters to be encoded. Most browsers do not encode them\r\n * in encodeURI https://github.com/whatwg/url/issues/369, so it may be safer to\r\n * also encode `!'()*`. Leaving unencoded only ASCII alphanumeric(`a-zA-Z0-9`)\r\n * plus `-._~`. This extra safety should be applied to query by patching the\r\n * string returned by encodeURIComponent encodeURI also encodes `[\\]^`. `\\`\r\n * should be encoded to avoid ambiguity. Browsers (IE, FF, C) transform a `\\`\r\n * into a `/` if directly typed in. The _backtick_ (`````) should also be\r\n * encoded everywhere because some browsers like FF encode it when directly\r\n * written while others don't. Safari and IE don't encode ``\"<>{}``` in hash.\r\n */\r\n// const EXTRA_RESERVED_RE = /[!'()*]/g\r\n// const encodeReservedReplacer = (c: string) => '%' + c.charCodeAt(0).toString(16)\r\nconst HASH_RE = /#/g; // %23\r\nconst AMPERSAND_RE = /&/g; // %26\r\nconst SLASH_RE = /\\//g; // %2F\r\nconst EQUAL_RE = /=/g; // %3D\r\nconst IM_RE = /\\?/g; // %3F\r\nconst PLUS_RE = /\\+/g; // %2B\r\n/**\r\n * NOTE: It's not clear to me if we should encode the + symbol in queries, it\r\n * seems to be less flexible than not doing so and I can't find out the legacy\r\n * systems requiring this for regular requests like text/html. In the standard,\r\n * the encoding of the plus character is only mentioned for\r\n * application/x-www-form-urlencoded\r\n * (https://url.spec.whatwg.org/#urlencoded-parsing) and most browsers seems lo\r\n * leave the plus character as is in queries. To be more flexible, we allow the\r\n * plus character on the query but it can also be manually encoded by the user.\r\n *\r\n * Resources:\r\n * - https://url.spec.whatwg.org/#urlencoded-parsing\r\n * - https://stackoverflow.com/questions/1634271/url-encoding-the-space-character-or-20\r\n */\r\nconst ENC_BRACKET_OPEN_RE = /%5B/g; // [\r\nconst ENC_BRACKET_CLOSE_RE = /%5D/g; // ]\r\nconst ENC_CARET_RE = /%5E/g; // ^\r\nconst ENC_BACKTICK_RE = /%60/g; // `\r\nconst ENC_CURLY_OPEN_RE = /%7B/g; // {\r\nconst ENC_PIPE_RE = /%7C/g; // |\r\nconst ENC_CURLY_CLOSE_RE = /%7D/g; // }\r\nconst ENC_SPACE_RE = /%20/g; // }\r\n/**\r\n * Encode characters that need to be encoded on the path, search and hash\r\n * sections of the URL.\r\n *\r\n * @internal\r\n * @param text - string to encode\r\n * @returns encoded string\r\n */\r\nfunction commonEncode(text) {\r\n    return encodeURI('' + text)\r\n        .replace(ENC_PIPE_RE, '|')\r\n        .replace(ENC_BRACKET_OPEN_RE, '[')\r\n        .replace(ENC_BRACKET_CLOSE_RE, ']');\r\n}\r\n/**\r\n * Encode characters that need to be encoded on the hash section of the URL.\r\n *\r\n * @param text - string to encode\r\n * @returns encoded string\r\n */\r\nfunction encodeHash(text) {\r\n    return commonEncode(text)\r\n        .replace(ENC_CURLY_OPEN_RE, '{')\r\n        .replace(ENC_CURLY_CLOSE_RE, '}')\r\n        .replace(ENC_CARET_RE, '^');\r\n}\r\n/**\r\n * Encode characters that need to be encoded query values on the query\r\n * section of the URL.\r\n *\r\n * @param text - string to encode\r\n * @returns encoded string\r\n */\r\nfunction encodeQueryValue(text) {\r\n    return (commonEncode(text)\r\n        // Encode the space as +, encode the + to differentiate it from the space\r\n        .replace(PLUS_RE, '%2B')\r\n        .replace(ENC_SPACE_RE, '+')\r\n        .replace(HASH_RE, '%23')\r\n        .replace(AMPERSAND_RE, '%26')\r\n        .replace(ENC_BACKTICK_RE, '`')\r\n        .replace(ENC_CURLY_OPEN_RE, '{')\r\n        .replace(ENC_CURLY_CLOSE_RE, '}')\r\n        .replace(ENC_CARET_RE, '^'));\r\n}\r\n/**\r\n * Like `encodeQueryValue` but also encodes the `=` character.\r\n *\r\n * @param text - string to encode\r\n */\r\nfunction encodeQueryKey(text) {\r\n    return encodeQueryValue(text).replace(EQUAL_RE, '%3D');\r\n}\r\n/**\r\n * Encode characters that need to be encoded on the path section of the URL.\r\n *\r\n * @param text - string to encode\r\n * @returns encoded string\r\n */\r\nfunction encodePath(text) {\r\n    return commonEncode(text).replace(HASH_RE, '%23').replace(IM_RE, '%3F');\r\n}\r\n/**\r\n * Encode characters that need to be encoded on the path section of the URL as a\r\n * param. This function encodes everything {@link encodePath} does plus the\r\n * slash (`/`) character.\r\n *\r\n * @param text - string to encode\r\n * @returns encoded string\r\n */\r\nfunction encodeParam(text) {\r\n    return encodePath(text).replace(SLASH_RE, '%2F');\r\n}\r\n/**\r\n * Decode text using `decodeURIComponent`. Returns the original text if it\r\n * fails.\r\n *\r\n * @param text - string to decode\r\n * @returns decoded string\r\n */\r\nfunction decode(text) {\r\n    try {\r\n        return decodeURIComponent('' + text);\r\n    }\r\n    catch (err) {\r\n        (process.env.NODE_ENV !== 'production') && warn(`Error decoding \"${text}\". Using original value`);\r\n    }\r\n    return '' + text;\r\n}\n\n/**\r\n * Transforms a queryString into a {@link LocationQuery} object. Accept both, a\r\n * version with the leading `?` and without Should work as URLSearchParams\r\n\n * @internal\r\n *\r\n * @param search - search string to parse\r\n * @returns a query object\r\n */\r\nfunction parseQuery(search) {\r\n    const query = {};\r\n    // avoid creating an object with an empty key and empty value\r\n    // because of split('&')\r\n    if (search === '' || search === '?')\r\n        return query;\r\n    const hasLeadingIM = search[0] === '?';\r\n    const searchParams = (hasLeadingIM ? search.slice(1) : search).split('&');\r\n    for (let i = 0; i < searchParams.length; ++i) {\r\n        // pre decode the + into space\r\n        const searchParam = searchParams[i].replace(PLUS_RE, ' ');\r\n        // allow the = character\r\n        let eqPos = searchParam.indexOf('=');\r\n        let key = decode(eqPos < 0 ? searchParam : searchParam.slice(0, eqPos));\r\n        // this ignores ?__proto__&toString\r\n        if (Object.prototype.hasOwnProperty(key)) {\r\n            continue;\r\n        }\r\n        let value = eqPos < 0 ? null : decode(searchParam.slice(eqPos + 1));\r\n        if (key in query) {\r\n            // an extra variable for ts types\r\n            let currentValue = query[key];\r\n            if (!Array.isArray(currentValue)) {\r\n                currentValue = query[key] = [currentValue];\r\n            }\r\n            currentValue.push(value);\r\n        }\r\n        else {\r\n            query[key] = value;\r\n        }\r\n    }\r\n    return query;\r\n}\r\n/**\r\n * Stringifies a {@link LocationQueryRaw} object. Like `URLSearchParams`, it\r\n * doesn't prepend a `?`\r\n *\r\n * @internal\r\n *\r\n * @param query - query object to stringify\r\n * @returns string version of the query without the leading `?`\r\n */\r\nfunction stringifyQuery(query) {\r\n    let search = '';\r\n    for (let key in query) {\r\n        const value = query[key];\r\n        key = encodeQueryKey(key);\r\n        if (value == null) {\r\n            // only null adds the value\r\n            if (value !== undefined) {\r\n                search += (search.length ? '&' : '') + key;\r\n            }\r\n            continue;\r\n        }\r\n        // keep null values\r\n        let values = Array.isArray(value)\r\n            ? value.map(v => v && encodeQueryValue(v))\r\n            : [value && encodeQueryValue(value)];\r\n        values.forEach(value => {\r\n            // skip undefined values in arrays as if they were not present\r\n            // smaller code than using filter\r\n            if (value !== undefined) {\r\n                // only append & with non-empty search\r\n                search += (search.length ? '&' : '') + key;\r\n                if (value != null)\r\n                    search += '=' + value;\r\n            }\r\n        });\r\n    }\r\n    return search;\r\n}\r\n/**\r\n * Transforms a {@link LocationQueryRaw} into a {@link LocationQuery} by casting\r\n * numbers into strings, removing keys with an undefined value and replacing\r\n * undefined with null in arrays\r\n *\r\n * @param query - query object to normalize\r\n * @returns a normalized query object\r\n */\r\nfunction normalizeQuery(query) {\r\n    const normalizedQuery = {};\r\n    for (let key in query) {\r\n        let value = query[key];\r\n        if (value !== undefined) {\r\n            normalizedQuery[key] = Array.isArray(value)\r\n                ? value.map(v => (v == null ? null : '' + v))\r\n                : value == null\r\n                    ? value\r\n                    : '' + value;\r\n        }\r\n    }\r\n    return normalizedQuery;\r\n}\n\n/**\r\n * Create a list of callbacks that can be reset. Used to create before and after navigation guards list\r\n */\r\nfunction useCallbacks() {\r\n    let handlers = [];\r\n    function add(handler) {\r\n        handlers.push(handler);\r\n        return () => {\r\n            const i = handlers.indexOf(handler);\r\n            if (i > -1)\r\n                handlers.splice(i, 1);\r\n        };\r\n    }\r\n    function reset() {\r\n        handlers = [];\r\n    }\r\n    return {\r\n        add,\r\n        list: () => handlers,\r\n        reset,\r\n    };\r\n}\n\nfunction registerGuard(record, name, guard) {\r\n    const removeFromList = () => {\r\n        record[name].delete(guard);\r\n    };\r\n    onUnmounted(removeFromList);\r\n    onDeactivated(removeFromList);\r\n    onActivated(() => {\r\n        record[name].add(guard);\r\n    });\r\n    record[name].add(guard);\r\n}\r\n/**\r\n * Add a navigation guard that triggers whenever the component for the current\r\n * location is about to be left. Similar to {@link beforeRouteLeave} but can be\r\n * used in any component. The guard is removed when the component is unmounted.\r\n *\r\n * @param leaveGuard - {@link NavigationGuard}\r\n */\r\nfunction onBeforeRouteLeave(leaveGuard) {\r\n    if ((process.env.NODE_ENV !== 'production') && !getCurrentInstance()) {\r\n        warn('getCurrentInstance() returned null. onBeforeRouteLeave() must be called at the top of a setup function');\r\n        return;\r\n    }\r\n    const activeRecord = inject(matchedRouteKey, {}).value;\r\n    if (!activeRecord) {\r\n        (process.env.NODE_ENV !== 'production') &&\r\n            warn('No active route record was found. Are you missing a <router-view> component?');\r\n        return;\r\n    }\r\n    registerGuard(activeRecord, 'leaveGuards', leaveGuard);\r\n}\r\n/**\r\n * Add a navigation guard that triggers whenever the current location is about\r\n * to be updated. Similar to {@link beforeRouteUpdate} but can be used in any\r\n * component. The guard is removed when the component is unmounted.\r\n *\r\n * @param updateGuard - {@link NavigationGuard}\r\n */\r\nfunction onBeforeRouteUpdate(updateGuard) {\r\n    if ((process.env.NODE_ENV !== 'production') && !getCurrentInstance()) {\r\n        warn('getCurrentInstance() returned null. onBeforeRouteUpdate() must be called at the top of a setup function');\r\n        return;\r\n    }\r\n    const activeRecord = inject(matchedRouteKey, {}).value;\r\n    if (!activeRecord) {\r\n        (process.env.NODE_ENV !== 'production') &&\r\n            warn('No active route record was found. Are you missing a <router-view> component?');\r\n        return;\r\n    }\r\n    registerGuard(activeRecord, 'updateGuards', updateGuard);\r\n}\r\nfunction guardToPromiseFn(guard, to, from, record, name) {\r\n    // keep a reference to the enterCallbackArray to prevent pushing callbacks if a new navigation took place\r\n    const enterCallbackArray = record &&\r\n        // name is defined if record is because of the function overload\r\n        (record.enterCallbacks[name] = record.enterCallbacks[name] || []);\r\n    return () => new Promise((resolve, reject) => {\r\n        const next = (valid) => {\r\n            if (valid === false)\r\n                reject(createRouterError(4 /* NAVIGATION_ABORTED */, {\r\n                    from,\r\n                    to,\r\n                }));\r\n            else if (valid instanceof Error) {\r\n                reject(valid);\r\n            }\r\n            else if (isRouteLocation(valid)) {\r\n                reject(createRouterError(2 /* NAVIGATION_GUARD_REDIRECT */, {\r\n                    from: to,\r\n                    to: valid,\r\n                }));\r\n            }\r\n            else {\r\n                if (enterCallbackArray &&\r\n                    // since enterCallbackArray is truthy, both record and name also are\r\n                    record.enterCallbacks[name] === enterCallbackArray &&\r\n                    typeof valid === 'function')\r\n                    enterCallbackArray.push(valid);\r\n                resolve();\r\n            }\r\n        };\r\n        // wrapping with Promise.resolve allows it to work with both async and sync guards\r\n        const guardReturn = guard.call(record && record.instances[name], to, from, (process.env.NODE_ENV !== 'production') ? canOnlyBeCalledOnce(next, to, from) : next);\r\n        let guardCall = Promise.resolve(guardReturn);\r\n        if (guard.length < 3)\r\n            guardCall = guardCall.then(next);\r\n        if ((process.env.NODE_ENV !== 'production') && guard.length > 2) {\r\n            const message = `The \"next\" callback was never called inside of ${guard.name ? '\"' + guard.name + '\"' : ''}:\\n${guard.toString()}\\n. If you are returning a value instead of calling \"next\", make sure to remove the \"next\" parameter from your function.`;\r\n            if (typeof guardReturn === 'object' && 'then' in guardReturn) {\r\n                guardCall = guardCall.then(resolvedValue => {\r\n                    // @ts-ignore: _called is added at canOnlyBeCalledOnce\r\n                    if (!next._called) {\r\n                        warn(message);\r\n                        return Promise.reject(new Error('Invalid navigation guard'));\r\n                    }\r\n                    return resolvedValue;\r\n                });\r\n                // TODO: test me!\r\n            }\r\n            else if (guardReturn !== undefined) {\r\n                // @ts-ignore: _called is added at canOnlyBeCalledOnce\r\n                if (!next._called) {\r\n                    warn(message);\r\n                    reject(new Error('Invalid navigation guard'));\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n        guardCall.catch(err => reject(err));\r\n    });\r\n}\r\nfunction canOnlyBeCalledOnce(next, to, from) {\r\n    let called = 0;\r\n    return function () {\r\n        if (called++ === 1)\r\n            warn(`The \"next\" callback was called more than once in one navigation guard when going from \"${from.fullPath}\" to \"${to.fullPath}\". It should be called exactly one time in each navigation guard. This will fail in production.`);\r\n        // @ts-ignore: we put it in the original one because it's easier to check\r\n        next._called = true;\r\n        if (called === 1)\r\n            next.apply(null, arguments);\r\n    };\r\n}\r\nfunction extractComponentsGuards(matched, guardType, to, from) {\r\n    const guards = [];\r\n    for (const record of matched) {\r\n        for (const name in record.components) {\r\n            let rawComponent = record.components[name];\r\n            if ((process.env.NODE_ENV !== 'production')) {\r\n                if (!rawComponent ||\r\n                    (typeof rawComponent !== 'object' &&\r\n                        typeof rawComponent !== 'function')) {\r\n                    warn(`Component \"${name}\" in record with path \"${record.path}\" is not` +\r\n                        ` a valid component. Received \"${String(rawComponent)}\".`);\r\n                    // throw to ensure we stop here but warn to ensure the message isn't\r\n                    // missed by the user\r\n                    throw new Error('Invalid route component');\r\n                }\r\n                else if ('then' in rawComponent) {\r\n                    // warn if user wrote import('/component.vue') instead of () =>\r\n                    // import('./component.vue')\r\n                    warn(`Component \"${name}\" in record with path \"${record.path}\" is a ` +\r\n                        `Promise instead of a function that returns a Promise. Did you ` +\r\n                        `write \"import('./MyPage.vue')\" instead of ` +\r\n                        `\"() => import('./MyPage.vue')\" ? This will break in ` +\r\n                        `production if not fixed.`);\r\n                    let promise = rawComponent;\r\n                    rawComponent = () => promise;\r\n                }\r\n                else if (rawComponent.__asyncLoader &&\r\n                    // warn only once per component\r\n                    !rawComponent.__warnedDefineAsync) {\r\n                    rawComponent.__warnedDefineAsync = true;\r\n                    warn(`Component \"${name}\" in record with path \"${record.path}\" is defined ` +\r\n                        `using \"defineAsyncComponent()\". ` +\r\n                        `Write \"() => import('./MyPage.vue')\" instead of ` +\r\n                        `\"defineAsyncComponent(() => import('./MyPage.vue'))\".`);\r\n                }\r\n            }\r\n            // skip update and leave guards if the route component is not mounted\r\n            if (guardType !== 'beforeRouteEnter' && !record.instances[name])\r\n                continue;\r\n            if (isRouteComponent(rawComponent)) {\r\n                // __vccOpts is added by vue-class-component and contain the regular options\r\n                let options = rawComponent.__vccOpts || rawComponent;\r\n                const guard = options[guardType];\r\n                guard && guards.push(guardToPromiseFn(guard, to, from, record, name));\r\n            }\r\n            else {\r\n                // start requesting the chunk already\r\n                let componentPromise = rawComponent();\r\n                if ((process.env.NODE_ENV !== 'production') && !('catch' in componentPromise)) {\r\n                    warn(`Component \"${name}\" in record with path \"${record.path}\" is a function that does not return a Promise. If you were passing a functional component, make sure to add a \"displayName\" to the component. This will break in production if not fixed.`);\r\n                    componentPromise = Promise.resolve(componentPromise);\r\n                }\r\n                else {\r\n                    // display the error if any\r\n                    componentPromise = componentPromise.catch(console.error);\r\n                }\r\n                guards.push(() => componentPromise.then(resolved => {\r\n                    if (!resolved)\r\n                        return Promise.reject(new Error(`Couldn't resolve component \"${name}\" at \"${record.path}\"`));\r\n                    const resolvedComponent = isESModule(resolved)\r\n                        ? resolved.default\r\n                        : resolved;\r\n                    // replace the function with the resolved component\r\n                    record.components[name] = resolvedComponent;\r\n                    // __vccOpts is added by vue-class-component and contain the regular options\r\n                    let options = resolvedComponent.__vccOpts || resolvedComponent;\r\n                    const guard = options[guardType];\r\n                    return guard && guardToPromiseFn(guard, to, from, record, name)();\r\n                }));\r\n            }\r\n        }\r\n    }\r\n    return guards;\r\n}\r\n/**\r\n * Allows differentiating lazy components from functional components and vue-class-component\r\n * @param component\r\n */\r\nfunction isRouteComponent(component) {\r\n    return (typeof component === 'object' ||\r\n        'displayName' in component ||\r\n        'props' in component ||\r\n        '__vccOpts' in component);\r\n}\n\n// TODO: we could allow currentRoute as a prop to expose `isActive` and\r\n// `isExactActive` behavior should go through an RFC\r\nfunction useLink(props) {\r\n    const router = inject(routerKey);\r\n    const currentRoute = inject(routeLocationKey);\r\n    const route = computed(() => router.resolve(unref(props.to)));\r\n    const activeRecordIndex = computed(() => {\r\n        let { matched } = route.value;\r\n        let { length } = matched;\r\n        const routeMatched = matched[length - 1];\r\n        let currentMatched = currentRoute.matched;\r\n        if (!routeMatched || !currentMatched.length)\r\n            return -1;\r\n        let index = currentMatched.findIndex(isSameRouteRecord.bind(null, routeMatched));\r\n        if (index > -1)\r\n            return index;\r\n        // possible parent record\r\n        let parentRecordPath = getOriginalPath(matched[length - 2]);\r\n        return (\r\n        // we are dealing with nested routes\r\n        length > 1 &&\r\n            // if the parent and matched route have the same path, this link is\r\n            // referring to the empty child. Or we currently are on a different\r\n            // child of the same parent\r\n            getOriginalPath(routeMatched) === parentRecordPath &&\r\n            // avoid comparing the child with its parent\r\n            currentMatched[currentMatched.length - 1].path !== parentRecordPath\r\n            ? currentMatched.findIndex(isSameRouteRecord.bind(null, matched[length - 2]))\r\n            : index);\r\n    });\r\n    const isActive = computed(() => activeRecordIndex.value > -1 &&\r\n        includesParams(currentRoute.params, route.value.params));\r\n    const isExactActive = computed(() => activeRecordIndex.value > -1 &&\r\n        activeRecordIndex.value === currentRoute.matched.length - 1 &&\r\n        isSameRouteLocationParams(currentRoute.params, route.value.params));\r\n    function navigate(e = {}) {\r\n        if (guardEvent(e))\r\n            return router[unref(props.replace) ? 'replace' : 'push'](unref(props.to));\r\n        return Promise.resolve();\r\n    }\r\n    return {\r\n        route,\r\n        href: computed(() => route.value.href),\r\n        isActive,\r\n        isExactActive,\r\n        navigate,\r\n    };\r\n}\r\nconst RouterLinkImpl = /*#__PURE__*/ defineComponent({\r\n    name: 'RouterLink',\r\n    props: {\r\n        to: {\r\n            type: [String, Object],\r\n            required: true,\r\n        },\r\n        replace: Boolean,\r\n        activeClass: String,\r\n        // inactiveClass: String,\r\n        exactActiveClass: String,\r\n        custom: Boolean,\r\n        ariaCurrentValue: {\r\n            type: String,\r\n            default: 'page',\r\n        },\r\n    },\r\n    setup(props, { slots }) {\r\n        const link = reactive(useLink(props));\r\n        const { options } = inject(routerKey);\r\n        const elClass = computed(() => ({\r\n            [getLinkClass(props.activeClass, options.linkActiveClass, 'router-link-active')]: link.isActive,\r\n            // [getLinkClass(\r\n            //   props.inactiveClass,\r\n            //   options.linkInactiveClass,\r\n            //   'router-link-inactive'\r\n            // )]: !link.isExactActive,\r\n            [getLinkClass(props.exactActiveClass, options.linkExactActiveClass, 'router-link-exact-active')]: link.isExactActive,\r\n        }));\r\n        // devtools only\r\n        if (((process.env.NODE_ENV !== 'production') || __VUE_PROD_DEVTOOLS__) && isBrowser) {\r\n            const instance = getCurrentInstance();\r\n            watchEffect(() => {\r\n                if (!instance)\r\n                    return;\r\n                instance.__vrl_route = link.route;\r\n            }, { flush: 'post' });\r\n            watchEffect(() => {\r\n                if (!instance)\r\n                    return;\r\n                instance.__vrl_active = link.isActive;\r\n                instance.__vrl_exactActive = link.isExactActive;\r\n            }, { flush: 'post' });\r\n        }\r\n        return () => {\r\n            const children = slots.default && slots.default(link);\r\n            return props.custom\r\n                ? children\r\n                : h('a', {\r\n                    'aria-current': link.isExactActive\r\n                        ? props.ariaCurrentValue\r\n                        : null,\r\n                    href: link.href,\r\n                    // this would override user added attrs but Vue will still add\r\n                    // the listener so we end up triggering both\r\n                    onClick: link.navigate,\r\n                    class: elClass.value,\r\n                }, children);\r\n        };\r\n    },\r\n});\r\n// export the public type for h/tsx inference\r\n// also to avoid inline import() in generated d.ts files\r\n/**\r\n * Component to render a link that triggers a navigation on click.\r\n */\r\nconst RouterLink = RouterLinkImpl;\r\nfunction guardEvent(e) {\r\n    // don't redirect with control keys\r\n    if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)\r\n        return;\r\n    // don't redirect when preventDefault called\r\n    if (e.defaultPrevented)\r\n        return;\r\n    // don't redirect on right click\r\n    if (e.button !== undefined && e.button !== 0)\r\n        return;\r\n    // don't redirect if `target=\"_blank\"`\r\n    // @ts-ignore getAttribute does exist\r\n    if (e.currentTarget && e.currentTarget.getAttribute) {\r\n        // @ts-ignore getAttribute exists\r\n        const target = e.currentTarget.getAttribute('target');\r\n        if (/\\b_blank\\b/i.test(target))\r\n            return;\r\n    }\r\n    // this may be a Weex event which doesn't have this method\r\n    if (e.preventDefault)\r\n        e.preventDefault();\r\n    return true;\r\n}\r\nfunction includesParams(outer, inner) {\r\n    for (let key in inner) {\r\n        let innerValue = inner[key];\r\n        let outerValue = outer[key];\r\n        if (typeof innerValue === 'string') {\r\n            if (innerValue !== outerValue)\r\n                return false;\r\n        }\r\n        else {\r\n            if (!Array.isArray(outerValue) ||\r\n                outerValue.length !== innerValue.length ||\r\n                innerValue.some((value, i) => value !== outerValue[i]))\r\n                return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * Get the original path value of a record by following its aliasOf\r\n * @param record\r\n */\r\nfunction getOriginalPath(record) {\r\n    return record ? (record.aliasOf ? record.aliasOf.path : record.path) : '';\r\n}\r\n/**\r\n * Utility class to get the active class based on defaults.\r\n * @param propClass\r\n * @param globalClass\r\n * @param defaultClass\r\n */\r\nconst getLinkClass = (propClass, globalClass, defaultClass) => propClass != null\r\n    ? propClass\r\n    : globalClass != null\r\n        ? globalClass\r\n        : defaultClass;\n\nconst RouterViewImpl = /*#__PURE__*/ defineComponent({\r\n    name: 'RouterView',\r\n    // #674 we manually inherit them\r\n    inheritAttrs: false,\r\n    props: {\r\n        name: {\r\n            type: String,\r\n            default: 'default',\r\n        },\r\n        route: Object,\r\n    },\r\n    setup(props, { attrs, slots }) {\r\n        (process.env.NODE_ENV !== 'production') && warnDeprecatedUsage();\r\n        const injectedRoute = inject(routerViewLocationKey);\r\n        const routeToDisplay = computed(() => props.route || injectedRoute.value);\r\n        const depth = inject(viewDepthKey, 0);\r\n        const matchedRouteRef = computed(() => routeToDisplay.value.matched[depth]);\r\n        provide(viewDepthKey, depth + 1);\r\n        provide(matchedRouteKey, matchedRouteRef);\r\n        provide(routerViewLocationKey, routeToDisplay);\r\n        const viewRef = ref();\r\n        // watch at the same time the component instance, the route record we are\r\n        // rendering, and the name\r\n        watch(() => [viewRef.value, matchedRouteRef.value, props.name], ([instance, to, name], [oldInstance, from, oldName]) => {\r\n            // copy reused instances\r\n            if (to) {\r\n                // this will update the instance for new instances as well as reused\r\n                // instances when navigating to a new route\r\n                to.instances[name] = instance;\r\n                // the component instance is reused for a different route or name so\r\n                // we copy any saved update or leave guards. With async setup, the\r\n                // mounting component will mount before the matchedRoute changes,\r\n                // making instance === oldInstance, so we check if guards have been\r\n                // added before. This works because we remove guards when\r\n                // unmounting/deactivating components\r\n                if (from && from !== to && instance && instance === oldInstance) {\r\n                    if (!to.leaveGuards.size) {\r\n                        to.leaveGuards = from.leaveGuards;\r\n                    }\r\n                    if (!to.updateGuards.size) {\r\n                        to.updateGuards = from.updateGuards;\r\n                    }\r\n                }\r\n            }\r\n            // trigger beforeRouteEnter next callbacks\r\n            if (instance &&\r\n                to &&\r\n                // if there is no instance but to and from are the same this might be\r\n                // the first visit\r\n                (!from || !isSameRouteRecord(to, from) || !oldInstance)) {\r\n                (to.enterCallbacks[name] || []).forEach(callback => callback(instance));\r\n            }\r\n        }, { flush: 'post' });\r\n        return () => {\r\n            const route = routeToDisplay.value;\r\n            const matchedRoute = matchedRouteRef.value;\r\n            const ViewComponent = matchedRoute && matchedRoute.components[props.name];\r\n            // we need the value at the time we render because when we unmount, we\r\n            // navigated to a different location so the value is different\r\n            const currentName = props.name;\r\n            if (!ViewComponent) {\r\n                return normalizeSlot(slots.default, { Component: ViewComponent, route });\r\n            }\r\n            // props from route configuration\r\n            const routePropsOption = matchedRoute.props[props.name];\r\n            const routeProps = routePropsOption\r\n                ? routePropsOption === true\r\n                    ? route.params\r\n                    : typeof routePropsOption === 'function'\r\n                        ? routePropsOption(route)\r\n                        : routePropsOption\r\n                : null;\r\n            const onVnodeUnmounted = vnode => {\r\n                // remove the instance reference to prevent leak\r\n                if (vnode.component.isUnmounted) {\r\n                    matchedRoute.instances[currentName] = null;\r\n                }\r\n            };\r\n            const component = h(ViewComponent, assign({}, routeProps, attrs, {\r\n                onVnodeUnmounted,\r\n                ref: viewRef,\r\n            }));\r\n            return (\r\n            // pass the vnode to the slot as a prop.\r\n            // h and <component :is=\"...\"> both accept vnodes\r\n            normalizeSlot(slots.default, { Component: component, route }) ||\r\n                component);\r\n        };\r\n    },\r\n});\r\nfunction normalizeSlot(slot, data) {\r\n    if (!slot)\r\n        return null;\r\n    const slotContent = slot(data);\r\n    return slotContent.length === 1 ? slotContent[0] : slotContent;\r\n}\r\n// export the public type for h/tsx inference\r\n// also to avoid inline import() in generated d.ts files\r\n/**\r\n * Component to display the current route the user is at.\r\n */\r\nconst RouterView = RouterViewImpl;\r\n// warn against deprecated usage with <transition> & <keep-alive>\r\n// due to functional component being no longer eager in Vue 3\r\nfunction warnDeprecatedUsage() {\r\n    const instance = getCurrentInstance();\r\n    const parentName = instance.parent && instance.parent.type.name;\r\n    if (parentName &&\r\n        (parentName === 'KeepAlive' || parentName.includes('Transition'))) {\r\n        const comp = parentName === 'KeepAlive' ? 'keep-alive' : 'transition';\r\n        warn(`<router-view> can no longer be used directly inside <transition> or <keep-alive>.\\n` +\r\n            `Use slot props instead:\\n\\n` +\r\n            `<router-view v-slot=\"{ Component }\">\\n` +\r\n            `  <${comp}>\\n` +\r\n            `    <component :is=\"Component\" />\\n` +\r\n            `  </${comp}>\\n` +\r\n            `</router-view>`);\r\n    }\r\n}\n\nfunction formatRouteLocation(routeLocation, tooltip) {\r\n    const copy = assign({}, routeLocation, {\r\n        // remove variables that can contain vue instances\r\n        matched: routeLocation.matched.map(matched => omit(matched, ['instances', 'children', 'aliasOf'])),\r\n    });\r\n    return {\r\n        _custom: {\r\n            type: null,\r\n            readOnly: true,\r\n            display: routeLocation.fullPath,\r\n            tooltip,\r\n            value: copy,\r\n        },\r\n    };\r\n}\r\nfunction formatDisplay(display) {\r\n    return {\r\n        _custom: {\r\n            display,\r\n        },\r\n    };\r\n}\r\n// to support multiple router instances\r\nlet routerId = 0;\r\nfunction addDevtools(app, router, matcher) {\r\n    // Take over router.beforeEach and afterEach\r\n    // make sure we are not registering the devtool twice\r\n    if (router.__hasDevtools)\r\n        return;\r\n    router.__hasDevtools = true;\r\n    // increment to support multiple router instances\r\n    const id = routerId++;\r\n    setupDevtoolsPlugin({\r\n        id: 'org.vuejs.router' + (id ? '.' + id : ''),\r\n        label: 'Vue Router',\r\n        packageName: 'vue-router',\r\n        homepage: 'https://next.router.vuejs.org/',\r\n        logo: 'https://vuejs.org/images/icons/favicon-96x96.png',\r\n        componentStateTypes: ['Routing'],\r\n        app,\r\n    }, api => {\r\n        // display state added by the router\r\n        api.on.inspectComponent((payload, ctx) => {\r\n            if (payload.instanceData) {\r\n                payload.instanceData.state.push({\r\n                    type: 'Routing',\r\n                    key: '$route',\r\n                    editable: false,\r\n                    value: formatRouteLocation(router.currentRoute.value, 'Current Route'),\r\n                });\r\n            }\r\n        });\r\n        // mark router-link as active\r\n        api.on.visitComponentTree(({ treeNode: node, componentInstance }) => {\r\n            if (node.name === 'RouterLink') {\r\n                if (componentInstance.__vrl_route) {\r\n                    node.tags.push({\r\n                        label: componentInstance.__vrl_route.path,\r\n                        textColor: 0,\r\n                        backgroundColor: ORANGE_400,\r\n                    });\r\n                }\r\n                if (componentInstance.__vrl_exactActive) {\r\n                    node.tags.push({\r\n                        label: 'exact',\r\n                        textColor: 0,\r\n                        backgroundColor: LIME_500,\r\n                    });\r\n                }\r\n                if (componentInstance.__vrl_active) {\r\n                    node.tags.push({\r\n                        label: 'active',\r\n                        textColor: 0,\r\n                        backgroundColor: BLUE_600,\r\n                    });\r\n                }\r\n            }\r\n        });\r\n        watch(router.currentRoute, () => {\r\n            // refresh active state\r\n            refreshRoutesView();\r\n            api.notifyComponentUpdate();\r\n            api.sendInspectorTree(routerInspectorId);\r\n        });\r\n        const navigationsLayerId = 'router:navigations:' + id;\r\n        api.addTimelineLayer({\r\n            id: navigationsLayerId,\r\n            label: `Router${id ? ' ' + id : ''} Navigations`,\r\n            color: 0x40a8c4,\r\n        });\r\n        // const errorsLayerId = 'router:errors'\r\n        // api.addTimelineLayer({\r\n        //   id: errorsLayerId,\r\n        //   label: 'Router Errors',\r\n        //   color: 0xea5455,\r\n        // })\r\n        router.onError(error => {\r\n            api.addTimelineEvent({\r\n                layerId: navigationsLayerId,\r\n                event: {\r\n                    title: 'Error',\r\n                    subtitle: 'An uncaught error happened during navigation',\r\n                    logType: 'error',\r\n                    time: Date.now(),\r\n                    data: { error },\r\n                },\r\n            });\r\n        });\r\n        // attached to `meta` and used to group events\r\n        let navigationId = 0;\r\n        router.beforeEach((to, from) => {\r\n            const data = {\r\n                guard: formatDisplay('beforeEach'),\r\n                from: formatRouteLocation(from, 'Current Location during this navigation'),\r\n                to: formatRouteLocation(to, 'Target location'),\r\n            };\r\n            // Used to group navigations together, hide from devtools\r\n            Object.defineProperty(to.meta, '__navigationId', {\r\n                value: navigationId++,\r\n            });\r\n            api.addTimelineEvent({\r\n                layerId: navigationsLayerId,\r\n                event: {\r\n                    time: Date.now(),\r\n                    title: 'Start of navigation',\r\n                    data,\r\n                    groupId: to.meta.__navigationId,\r\n                },\r\n            });\r\n        });\r\n        router.afterEach((to, from, failure) => {\r\n            const data = {\r\n                guard: formatDisplay('afterEach'),\r\n            };\r\n            if (failure) {\r\n                data.failure = {\r\n                    _custom: {\r\n                        type: Error,\r\n                        readOnly: true,\r\n                        display: failure ? failure.message : '',\r\n                        tooltip: 'Navigation Failure',\r\n                        value: failure,\r\n                    },\r\n                };\r\n                data.status = formatDisplay('❌');\r\n            }\r\n            else {\r\n                data.status = formatDisplay('✅');\r\n            }\r\n            // we set here to have the right order\r\n            data.from = formatRouteLocation(from, 'Current Location during this navigation');\r\n            data.to = formatRouteLocation(to, 'Target location');\r\n            api.addTimelineEvent({\r\n                layerId: navigationsLayerId,\r\n                event: {\r\n                    title: 'End of navigation',\r\n                    time: Date.now(),\r\n                    data,\r\n                    logType: failure ? 'warning' : 'default',\r\n                    groupId: to.meta.__navigationId,\r\n                },\r\n            });\r\n        });\r\n        /**\r\n         * Inspector of Existing routes\r\n         */\r\n        const routerInspectorId = 'router-inspector:' + id;\r\n        api.addInspector({\r\n            id: routerInspectorId,\r\n            label: 'Routes' + (id ? ' ' + id : ''),\r\n            icon: 'book',\r\n            treeFilterPlaceholder: 'Search routes',\r\n        });\r\n        function refreshRoutesView() {\r\n            // the routes view isn't active\r\n            if (!activeRoutesPayload)\r\n                return;\r\n            const payload = activeRoutesPayload;\r\n            // children routes will appear as nested\r\n            let routes = matcher.getRoutes().filter(route => !route.parent);\r\n            // reset match state to false\r\n            routes.forEach(resetMatchStateOnRouteRecord);\r\n            // apply a match state if there is a payload\r\n            if (payload.filter) {\r\n                routes = routes.filter(route => \r\n                // save matches state based on the payload\r\n                isRouteMatching(route, payload.filter.toLowerCase()));\r\n            }\r\n            // mark active routes\r\n            routes.forEach(route => markRouteRecordActive(route, router.currentRoute.value));\r\n            payload.rootNodes = routes.map(formatRouteRecordForInspector);\r\n        }\r\n        let activeRoutesPayload;\r\n        api.on.getInspectorTree(payload => {\r\n            activeRoutesPayload = payload;\r\n            if (payload.app === app && payload.inspectorId === routerInspectorId) {\r\n                refreshRoutesView();\r\n            }\r\n        });\r\n        /**\r\n         * Display information about the currently selected route record\r\n         */\r\n        api.on.getInspectorState(payload => {\r\n            if (payload.app === app && payload.inspectorId === routerInspectorId) {\r\n                const routes = matcher.getRoutes();\r\n                const route = routes.find(route => route.record.__vd_id === payload.nodeId);\r\n                if (route) {\r\n                    payload.state = {\r\n                        options: formatRouteRecordMatcherForStateInspector(route),\r\n                    };\r\n                }\r\n            }\r\n        });\r\n        api.sendInspectorTree(routerInspectorId);\r\n        api.sendInspectorState(routerInspectorId);\r\n    });\r\n}\r\nfunction modifierForKey(key) {\r\n    if (key.optional) {\r\n        return key.repeatable ? '*' : '?';\r\n    }\r\n    else {\r\n        return key.repeatable ? '+' : '';\r\n    }\r\n}\r\nfunction formatRouteRecordMatcherForStateInspector(route) {\r\n    const { record } = route;\r\n    const fields = [\r\n        { editable: false, key: 'path', value: record.path },\r\n    ];\r\n    if (record.name != null) {\r\n        fields.push({\r\n            editable: false,\r\n            key: 'name',\r\n            value: record.name,\r\n        });\r\n    }\r\n    fields.push({ editable: false, key: 'regexp', value: route.re });\r\n    if (route.keys.length) {\r\n        fields.push({\r\n            editable: false,\r\n            key: 'keys',\r\n            value: {\r\n                _custom: {\r\n                    type: null,\r\n                    readOnly: true,\r\n                    display: route.keys\r\n                        .map(key => `${key.name}${modifierForKey(key)}`)\r\n                        .join(' '),\r\n                    tooltip: 'Param keys',\r\n                    value: route.keys,\r\n                },\r\n            },\r\n        });\r\n    }\r\n    if (record.redirect != null) {\r\n        fields.push({\r\n            editable: false,\r\n            key: 'redirect',\r\n            value: record.redirect,\r\n        });\r\n    }\r\n    if (route.alias.length) {\r\n        fields.push({\r\n            editable: false,\r\n            key: 'aliases',\r\n            value: route.alias.map(alias => alias.record.path),\r\n        });\r\n    }\r\n    fields.push({\r\n        key: 'score',\r\n        editable: false,\r\n        value: {\r\n            _custom: {\r\n                type: null,\r\n                readOnly: true,\r\n                display: route.score.map(score => score.join(', ')).join(' | '),\r\n                tooltip: 'Score used to sort routes',\r\n                value: route.score,\r\n            },\r\n        },\r\n    });\r\n    return fields;\r\n}\r\n/**\r\n * Extracted from tailwind palette\r\n */\r\nconst PINK_500 = 0xec4899;\r\nconst BLUE_600 = 0x2563eb;\r\nconst LIME_500 = 0x84cc16;\r\nconst CYAN_400 = 0x22d3ee;\r\nconst ORANGE_400 = 0xfb923c;\r\n// const GRAY_100 = 0xf4f4f5\r\nconst DARK = 0x666666;\r\nfunction formatRouteRecordForInspector(route) {\r\n    const tags = [];\r\n    const { record } = route;\r\n    if (record.name != null) {\r\n        tags.push({\r\n            label: String(record.name),\r\n            textColor: 0,\r\n            backgroundColor: CYAN_400,\r\n        });\r\n    }\r\n    if (record.aliasOf) {\r\n        tags.push({\r\n            label: 'alias',\r\n            textColor: 0,\r\n            backgroundColor: ORANGE_400,\r\n        });\r\n    }\r\n    if (route.__vd_match) {\r\n        tags.push({\r\n            label: 'matches',\r\n            textColor: 0,\r\n            backgroundColor: PINK_500,\r\n        });\r\n    }\r\n    if (route.__vd_exactActive) {\r\n        tags.push({\r\n            label: 'exact',\r\n            textColor: 0,\r\n            backgroundColor: LIME_500,\r\n        });\r\n    }\r\n    if (route.__vd_active) {\r\n        tags.push({\r\n            label: 'active',\r\n            textColor: 0,\r\n            backgroundColor: BLUE_600,\r\n        });\r\n    }\r\n    if (record.redirect) {\r\n        tags.push({\r\n            label: 'redirect: ' +\r\n                (typeof record.redirect === 'string' ? record.redirect : 'Object'),\r\n            textColor: 0xffffff,\r\n            backgroundColor: DARK,\r\n        });\r\n    }\r\n    // add an id to be able to select it. Using the `path` is not possible because\r\n    // empty path children would collide with their parents\r\n    let id = record.__vd_id;\r\n    if (id == null) {\r\n        id = String(routeRecordId++);\r\n        record.__vd_id = id;\r\n    }\r\n    return {\r\n        id,\r\n        label: record.path,\r\n        tags,\r\n        children: route.children.map(formatRouteRecordForInspector),\r\n    };\r\n}\r\n//  incremental id for route records and inspector state\r\nlet routeRecordId = 0;\r\nconst EXTRACT_REGEXP_RE = /^\\/(.*)\\/([a-z]*)$/;\r\nfunction markRouteRecordActive(route, currentRoute) {\r\n    // no route will be active if matched is empty\r\n    // reset the matching state\r\n    const isExactActive = currentRoute.matched.length &&\r\n        isSameRouteRecord(currentRoute.matched[currentRoute.matched.length - 1], route.record);\r\n    route.__vd_exactActive = route.__vd_active = isExactActive;\r\n    if (!isExactActive) {\r\n        route.__vd_active = currentRoute.matched.some(match => isSameRouteRecord(match, route.record));\r\n    }\r\n    route.children.forEach(childRoute => markRouteRecordActive(childRoute, currentRoute));\r\n}\r\nfunction resetMatchStateOnRouteRecord(route) {\r\n    route.__vd_match = false;\r\n    route.children.forEach(resetMatchStateOnRouteRecord);\r\n}\r\nfunction isRouteMatching(route, filter) {\r\n    const found = String(route.re).match(EXTRACT_REGEXP_RE);\r\n    route.__vd_match = false;\r\n    if (!found || found.length < 3) {\r\n        return false;\r\n    }\r\n    // use a regexp without $ at the end to match nested routes better\r\n    const nonEndingRE = new RegExp(found[1].replace(/\\$$/, ''), found[2]);\r\n    if (nonEndingRE.test(filter)) {\r\n        // mark children as matches\r\n        route.children.forEach(child => isRouteMatching(child, filter));\r\n        // exception case: `/`\r\n        if (route.record.path !== '/' || filter === '/') {\r\n            route.__vd_match = route.re.test(filter);\r\n            return true;\r\n        }\r\n        // hide the / route\r\n        return false;\r\n    }\r\n    const path = route.record.path.toLowerCase();\r\n    const decodedPath = decode(path);\r\n    // also allow partial matching on the path\r\n    if (!filter.startsWith('/') &&\r\n        (decodedPath.includes(filter) || path.includes(filter)))\r\n        return true;\r\n    if (decodedPath.startsWith(filter) || path.startsWith(filter))\r\n        return true;\r\n    if (route.record.name && String(route.record.name).includes(filter))\r\n        return true;\r\n    return route.children.some(child => isRouteMatching(child, filter));\r\n}\r\nfunction omit(obj, keys) {\r\n    const ret = {};\r\n    for (let key in obj) {\r\n        if (!keys.includes(key)) {\r\n            // @ts-ignore\r\n            ret[key] = obj[key];\r\n        }\r\n    }\r\n    return ret;\r\n}\n\n/**\r\n * Creates a Router instance that can be used by a Vue app.\r\n *\r\n * @param options - {@link RouterOptions}\r\n */\r\nfunction createRouter(options) {\r\n    const matcher = createRouterMatcher(options.routes, options);\r\n    let parseQuery$1 = options.parseQuery || parseQuery;\r\n    let stringifyQuery$1 = options.stringifyQuery || stringifyQuery;\r\n    let routerHistory = options.history;\r\n    if ((process.env.NODE_ENV !== 'production') && !routerHistory)\r\n        throw new Error('Provide the \"history\" option when calling \"createRouter()\":' +\r\n            ' https://next.router.vuejs.org/api/#history.');\r\n    const beforeGuards = useCallbacks();\r\n    const beforeResolveGuards = useCallbacks();\r\n    const afterGuards = useCallbacks();\r\n    const currentRoute = shallowRef(START_LOCATION_NORMALIZED);\r\n    let pendingLocation = START_LOCATION_NORMALIZED;\r\n    // leave the scrollRestoration if no scrollBehavior is provided\r\n    if (isBrowser && options.scrollBehavior && 'scrollRestoration' in history) {\r\n        history.scrollRestoration = 'manual';\r\n    }\r\n    const normalizeParams = applyToParams.bind(null, paramValue => '' + paramValue);\r\n    const encodeParams = applyToParams.bind(null, encodeParam);\r\n    const decodeParams = applyToParams.bind(null, decode);\r\n    function addRoute(parentOrRoute, route) {\r\n        let parent;\r\n        let record;\r\n        if (isRouteName(parentOrRoute)) {\r\n            parent = matcher.getRecordMatcher(parentOrRoute);\r\n            record = route;\r\n        }\r\n        else {\r\n            record = parentOrRoute;\r\n        }\r\n        return matcher.addRoute(record, parent);\r\n    }\r\n    function removeRoute(name) {\r\n        let recordMatcher = matcher.getRecordMatcher(name);\r\n        if (recordMatcher) {\r\n            matcher.removeRoute(recordMatcher);\r\n        }\r\n        else if ((process.env.NODE_ENV !== 'production')) {\r\n            warn(`Cannot remove non-existent route \"${String(name)}\"`);\r\n        }\r\n    }\r\n    function getRoutes() {\r\n        return matcher.getRoutes().map(routeMatcher => routeMatcher.record);\r\n    }\r\n    function hasRoute(name) {\r\n        return !!matcher.getRecordMatcher(name);\r\n    }\r\n    function resolve(rawLocation, currentLocation) {\r\n        // const objectLocation = routerLocationAsObject(rawLocation)\r\n        // we create a copy to modify it later\r\n        currentLocation = assign({}, currentLocation || currentRoute.value);\r\n        if (typeof rawLocation === 'string') {\r\n            let locationNormalized = parseURL(parseQuery$1, rawLocation, currentLocation.path);\r\n            let matchedRoute = matcher.resolve({ path: locationNormalized.path }, currentLocation);\r\n            let href = routerHistory.createHref(locationNormalized.fullPath);\r\n            if ((process.env.NODE_ENV !== 'production')) {\r\n                if (href.startsWith('//'))\r\n                    warn(`Location \"${rawLocation}\" resolved to \"${href}\". A resolved location cannot start with multiple slashes.`);\r\n                else if (!matchedRoute.matched.length) {\r\n                    warn(`No match found for location with path \"${rawLocation}\"`);\r\n                }\r\n            }\r\n            // locationNormalized is always a new object\r\n            return assign(locationNormalized, matchedRoute, {\r\n                params: decodeParams(matchedRoute.params),\r\n                hash: decode(locationNormalized.hash),\r\n                redirectedFrom: undefined,\r\n                href,\r\n            });\r\n        }\r\n        let matcherLocation;\r\n        // path could be relative in object as well\r\n        if ('path' in rawLocation) {\r\n            if ((process.env.NODE_ENV !== 'production') &&\r\n                'params' in rawLocation &&\r\n                !('name' in rawLocation) &&\r\n                Object.keys(rawLocation.params).length) {\r\n                warn(`Path \"${rawLocation.path}\" was passed with params but they will be ignored. Use a named route alongside params instead.`);\r\n            }\r\n            matcherLocation = assign({}, rawLocation, {\r\n                path: parseURL(parseQuery$1, rawLocation.path, currentLocation.path).path,\r\n            });\r\n        }\r\n        else {\r\n            // pass encoded values to the matcher so it can produce encoded path and fullPath\r\n            matcherLocation = assign({}, rawLocation, {\r\n                params: encodeParams(rawLocation.params),\r\n            });\r\n            // current location params are decoded, we need to encode them in case the\r\n            // matcher merges the params\r\n            currentLocation.params = encodeParams(currentLocation.params);\r\n        }\r\n        let matchedRoute = matcher.resolve(matcherLocation, currentLocation);\r\n        const hash = rawLocation.hash || '';\r\n        if ((process.env.NODE_ENV !== 'production') && hash && !hash.startsWith('#')) {\r\n            warn(`A \\`hash\\` should always start with the character \"#\". Replace \"${hash}\" with \"#${hash}\".`);\r\n        }\r\n        // decoding them) the matcher might have merged current location params so\r\n        // we need to run the decoding again\r\n        matchedRoute.params = normalizeParams(decodeParams(matchedRoute.params));\r\n        const fullPath = stringifyURL(stringifyQuery$1, assign({}, rawLocation, {\r\n            hash: encodeHash(hash),\r\n            path: matchedRoute.path,\r\n        }));\r\n        let href = routerHistory.createHref(fullPath);\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            if (href.startsWith('//')) {\r\n                warn(`Location \"${rawLocation}\" resolved to \"${href}\". A resolved location cannot start with multiple slashes.`);\r\n            }\r\n            else if (!matchedRoute.matched.length) {\r\n                warn(`No match found for location with path \"${'path' in rawLocation ? rawLocation.path : rawLocation}\"`);\r\n            }\r\n        }\r\n        return assign({\r\n            fullPath,\r\n            // keep the hash encoded so fullPath is effectively path + encodedQuery +\r\n            // hash\r\n            hash,\r\n            query: \r\n            // if the user is using a custom query lib like qs, we might have\r\n            // nested objects, so we keep the query as is, meaning it can contain\r\n            // numbers at `$route.query`, but at the point, the user will have to\r\n            // use their own type anyway.\r\n            // https://github.com/vuejs/vue-router-next/issues/328#issuecomment-649481567\r\n            stringifyQuery$1 === stringifyQuery\r\n                ? normalizeQuery(rawLocation.query)\r\n                : rawLocation.query,\r\n        }, matchedRoute, {\r\n            redirectedFrom: undefined,\r\n            href,\r\n        });\r\n    }\r\n    function locationAsObject(to) {\r\n        return typeof to === 'string'\r\n            ? parseURL(parseQuery$1, to, currentRoute.value.path)\r\n            : assign({}, to);\r\n    }\r\n    function checkCanceledNavigation(to, from) {\r\n        if (pendingLocation !== to) {\r\n            return createRouterError(8 /* NAVIGATION_CANCELLED */, {\r\n                from,\r\n                to,\r\n            });\r\n        }\r\n    }\r\n    function push(to) {\r\n        return pushWithRedirect(to);\r\n    }\r\n    function replace(to) {\r\n        return push(assign(locationAsObject(to), { replace: true }));\r\n    }\r\n    function handleRedirectRecord(to) {\r\n        const lastMatched = to.matched[to.matched.length - 1];\r\n        if (lastMatched && lastMatched.redirect) {\r\n            const { redirect } = lastMatched;\r\n            let newTargetLocation = typeof redirect === 'function' ? redirect(to) : redirect;\r\n            if (typeof newTargetLocation === 'string') {\r\n                newTargetLocation =\r\n                    newTargetLocation.indexOf('?') > -1 ||\r\n                        newTargetLocation.indexOf('#') > -1\r\n                        ? (newTargetLocation = locationAsObject(newTargetLocation))\r\n                        : { path: newTargetLocation };\r\n            }\r\n            if ((process.env.NODE_ENV !== 'production') &&\r\n                !('path' in newTargetLocation) &&\r\n                !('name' in newTargetLocation)) {\r\n                warn(`Invalid redirect found:\\n${JSON.stringify(newTargetLocation, null, 2)}\\n when navigating to \"${to.fullPath}\". A redirect must contain a name or path. This will break in production.`);\r\n                throw new Error('Invalid redirect');\r\n            }\r\n            return assign({\r\n                query: to.query,\r\n                hash: to.hash,\r\n                params: to.params,\r\n            }, newTargetLocation);\r\n        }\r\n    }\r\n    function pushWithRedirect(to, redirectedFrom) {\r\n        const targetLocation = (pendingLocation = resolve(to));\r\n        const from = currentRoute.value;\r\n        const data = to.state;\r\n        const force = to.force;\r\n        // to could be a string where `replace` is a function\r\n        const replace = to.replace === true;\r\n        const shouldRedirect = handleRedirectRecord(targetLocation);\r\n        if (shouldRedirect)\r\n            return pushWithRedirect(assign(locationAsObject(shouldRedirect), {\r\n                state: data,\r\n                force,\r\n                replace,\r\n            }), \r\n            // keep original redirectedFrom if it exists\r\n            redirectedFrom || targetLocation);\r\n        // if it was a redirect we already called `pushWithRedirect` above\r\n        const toLocation = targetLocation;\r\n        toLocation.redirectedFrom = redirectedFrom;\r\n        let failure;\r\n        if (!force && isSameRouteLocation(stringifyQuery$1, from, targetLocation)) {\r\n            failure = createRouterError(16 /* NAVIGATION_DUPLICATED */, { to: toLocation, from });\r\n            // trigger scroll to allow scrolling to the same anchor\r\n            handleScroll(from, from, \r\n            // this is a push, the only way for it to be triggered from a\r\n            // history.listen is with a redirect, which makes it become a push\r\n            true, \r\n            // This cannot be the first navigation because the initial location\r\n            // cannot be manually navigated to\r\n            false);\r\n        }\r\n        return (failure ? Promise.resolve(failure) : navigate(toLocation, from))\r\n            .catch((error) => isNavigationFailure(error)\r\n            ? error\r\n            : // reject any unknown error\r\n                triggerError(error))\r\n            .then((failure) => {\r\n            if (failure) {\r\n                if (isNavigationFailure(failure, 2 /* NAVIGATION_GUARD_REDIRECT */)) {\r\n                    if ((process.env.NODE_ENV !== 'production') &&\r\n                        // we are redirecting to the same location we were already at\r\n                        isSameRouteLocation(stringifyQuery$1, resolve(failure.to), toLocation) &&\r\n                        // and we have done it a couple of times\r\n                        redirectedFrom &&\r\n                        // @ts-ignore\r\n                        (redirectedFrom._count = redirectedFrom._count\r\n                            ? // @ts-ignore\r\n                                redirectedFrom._count + 1\r\n                            : 1) > 10) {\r\n                        warn(`Detected an infinite redirection in a navigation guard when going from \"${from.fullPath}\" to \"${toLocation.fullPath}\". Aborting to avoid a Stack Overflow. This will break in production if not fixed.`);\r\n                        return Promise.reject(new Error('Infinite redirect in navigation guard'));\r\n                    }\r\n                    return pushWithRedirect(\r\n                    // keep options\r\n                    assign(locationAsObject(failure.to), {\r\n                        state: data,\r\n                        force,\r\n                        replace,\r\n                    }), \r\n                    // preserve the original redirectedFrom if any\r\n                    redirectedFrom || toLocation);\r\n                }\r\n            }\r\n            else {\r\n                // if we fail we don't finalize the navigation\r\n                failure = finalizeNavigation(toLocation, from, true, replace, data);\r\n            }\r\n            triggerAfterEach(toLocation, from, failure);\r\n            return failure;\r\n        });\r\n    }\r\n    /**\r\n     * Helper to reject and skip all navigation guards if a new navigation happened\r\n     * @param to\r\n     * @param from\r\n     */\r\n    function checkCanceledNavigationAndReject(to, from) {\r\n        const error = checkCanceledNavigation(to, from);\r\n        return error ? Promise.reject(error) : Promise.resolve();\r\n    }\r\n    // TODO: refactor the whole before guards by internally using router.beforeEach\r\n    function navigate(to, from) {\r\n        let guards;\r\n        const [leavingRecords, updatingRecords, enteringRecords] = extractChangingRecords(to, from);\r\n        // all components here have been resolved once because we are leaving\r\n        guards = extractComponentsGuards(leavingRecords.reverse(), 'beforeRouteLeave', to, from);\r\n        // leavingRecords is already reversed\r\n        for (const record of leavingRecords) {\r\n            record.leaveGuards.forEach(guard => {\r\n                guards.push(guardToPromiseFn(guard, to, from));\r\n            });\r\n        }\r\n        const canceledNavigationCheck = checkCanceledNavigationAndReject.bind(null, to, from);\r\n        guards.push(canceledNavigationCheck);\r\n        // run the queue of per route beforeRouteLeave guards\r\n        return (runGuardQueue(guards)\r\n            .then(() => {\r\n            // check global guards beforeEach\r\n            guards = [];\r\n            for (const guard of beforeGuards.list()) {\r\n                guards.push(guardToPromiseFn(guard, to, from));\r\n            }\r\n            guards.push(canceledNavigationCheck);\r\n            return runGuardQueue(guards);\r\n        })\r\n            .then(() => {\r\n            // check in components beforeRouteUpdate\r\n            guards = extractComponentsGuards(updatingRecords, 'beforeRouteUpdate', to, from);\r\n            for (const record of updatingRecords) {\r\n                record.updateGuards.forEach(guard => {\r\n                    guards.push(guardToPromiseFn(guard, to, from));\r\n                });\r\n            }\r\n            guards.push(canceledNavigationCheck);\r\n            // run the queue of per route beforeEnter guards\r\n            return runGuardQueue(guards);\r\n        })\r\n            .then(() => {\r\n            // check the route beforeEnter\r\n            guards = [];\r\n            for (const record of to.matched) {\r\n                // do not trigger beforeEnter on reused views\r\n                if (record.beforeEnter && from.matched.indexOf(record) < 0) {\r\n                    if (Array.isArray(record.beforeEnter)) {\r\n                        for (const beforeEnter of record.beforeEnter)\r\n                            guards.push(guardToPromiseFn(beforeEnter, to, from));\r\n                    }\r\n                    else {\r\n                        guards.push(guardToPromiseFn(record.beforeEnter, to, from));\r\n                    }\r\n                }\r\n            }\r\n            guards.push(canceledNavigationCheck);\r\n            // run the queue of per route beforeEnter guards\r\n            return runGuardQueue(guards);\r\n        })\r\n            .then(() => {\r\n            // NOTE: at this point to.matched is normalized and does not contain any () => Promise<Component>\r\n            // clear existing enterCallbacks, these are added by extractComponentsGuards\r\n            to.matched.forEach(record => (record.enterCallbacks = {}));\r\n            // check in-component beforeRouteEnter\r\n            guards = extractComponentsGuards(enteringRecords, 'beforeRouteEnter', to, from);\r\n            guards.push(canceledNavigationCheck);\r\n            // run the queue of per route beforeEnter guards\r\n            return runGuardQueue(guards);\r\n        })\r\n            .then(() => {\r\n            // check global guards beforeResolve\r\n            guards = [];\r\n            for (const guard of beforeResolveGuards.list()) {\r\n                guards.push(guardToPromiseFn(guard, to, from));\r\n            }\r\n            guards.push(canceledNavigationCheck);\r\n            return runGuardQueue(guards);\r\n        })\r\n            // catch any navigation canceled\r\n            .catch(err => isNavigationFailure(err, 8 /* NAVIGATION_CANCELLED */)\r\n            ? err\r\n            : Promise.reject(err)));\r\n    }\r\n    function triggerAfterEach(to, from, failure) {\r\n        // navigation is confirmed, call afterGuards\r\n        // TODO: wrap with error handlers\r\n        for (const guard of afterGuards.list())\r\n            guard(to, from, failure);\r\n    }\r\n    /**\r\n     * - Cleans up any navigation guards\r\n     * - Changes the url if necessary\r\n     * - Calls the scrollBehavior\r\n     */\r\n    function finalizeNavigation(toLocation, from, isPush, replace, data) {\r\n        // a more recent navigation took place\r\n        const error = checkCanceledNavigation(toLocation, from);\r\n        if (error)\r\n            return error;\r\n        // only consider as push if it's not the first navigation\r\n        const isFirstNavigation = from === START_LOCATION_NORMALIZED;\r\n        const state = !isBrowser ? {} : history.state;\r\n        // change URL only if the user did a push/replace and if it's not the initial navigation because\r\n        // it's just reflecting the url\r\n        if (isPush) {\r\n            // on the initial navigation, we want to reuse the scroll position from\r\n            // history state if it exists\r\n            if (replace || isFirstNavigation)\r\n                routerHistory.replace(toLocation.fullPath, assign({\r\n                    scroll: isFirstNavigation && state && state.scroll,\r\n                }, data));\r\n            else\r\n                routerHistory.push(toLocation.fullPath, data);\r\n        }\r\n        // accept current navigation\r\n        currentRoute.value = toLocation;\r\n        handleScroll(toLocation, from, isPush, isFirstNavigation);\r\n        markAsReady();\r\n    }\r\n    let removeHistoryListener;\r\n    // attach listener to history to trigger navigations\r\n    function setupListeners() {\r\n        removeHistoryListener = routerHistory.listen((to, _from, info) => {\r\n            // cannot be a redirect route because it was in history\r\n            let toLocation = resolve(to);\r\n            // due to dynamic routing, and to hash history with manual navigation\r\n            // (manually changing the url or calling history.hash = '#/somewhere'),\r\n            // there could be a redirect record in history\r\n            const shouldRedirect = handleRedirectRecord(toLocation);\r\n            if (shouldRedirect) {\r\n                pushWithRedirect(assign(shouldRedirect, { replace: true }), toLocation).catch(noop);\r\n                return;\r\n            }\r\n            pendingLocation = toLocation;\r\n            const from = currentRoute.value;\r\n            // TODO: should be moved to web history?\r\n            if (isBrowser) {\r\n                saveScrollPosition(getScrollKey(from.fullPath, info.delta), computeScrollPosition());\r\n            }\r\n            navigate(toLocation, from)\r\n                .catch((error) => {\r\n                if (isNavigationFailure(error, 4 /* NAVIGATION_ABORTED */ | 8 /* NAVIGATION_CANCELLED */)) {\r\n                    return error;\r\n                }\r\n                if (isNavigationFailure(error, 2 /* NAVIGATION_GUARD_REDIRECT */)) {\r\n                    // Here we could call if (info.delta) routerHistory.go(-info.delta,\r\n                    // false) but this is bug prone as we have no way to wait the\r\n                    // navigation to be finished before calling pushWithRedirect. Using\r\n                    // a setTimeout of 16ms seems to work but there is not guarantee for\r\n                    // it to work on every browser. So Instead we do not restore the\r\n                    // history entry and trigger a new navigation as requested by the\r\n                    // navigation guard.\r\n                    // the error is already handled by router.push we just want to avoid\r\n                    // logging the error\r\n                    pushWithRedirect(error.to, toLocation\r\n                    // avoid an uncaught rejection, let push call triggerError\r\n                    ).catch(noop);\r\n                    // avoid the then branch\r\n                    return Promise.reject();\r\n                }\r\n                // do not restore history on unknown direction\r\n                if (info.delta)\r\n                    routerHistory.go(-info.delta, false);\r\n                // unrecognized error, transfer to the global handler\r\n                return triggerError(error);\r\n            })\r\n                .then((failure) => {\r\n                failure =\r\n                    failure ||\r\n                        finalizeNavigation(\r\n                        // after navigation, all matched components are resolved\r\n                        toLocation, from, false);\r\n                // revert the navigation\r\n                if (failure && info.delta)\r\n                    routerHistory.go(-info.delta, false);\r\n                triggerAfterEach(toLocation, from, failure);\r\n            })\r\n                .catch(noop);\r\n        });\r\n    }\r\n    // Initialization and Errors\r\n    let readyHandlers = useCallbacks();\r\n    let errorHandlers = useCallbacks();\r\n    let ready;\r\n    /**\r\n     * Trigger errorHandlers added via onError and throws the error as well\r\n     * @param error - error to throw\r\n     * @returns the error as a rejected promise\r\n     */\r\n    function triggerError(error) {\r\n        markAsReady(error);\r\n        errorHandlers.list().forEach(handler => handler(error));\r\n        return Promise.reject(error);\r\n    }\r\n    function isReady() {\r\n        if (ready && currentRoute.value !== START_LOCATION_NORMALIZED)\r\n            return Promise.resolve();\r\n        return new Promise((resolve, reject) => {\r\n            readyHandlers.add([resolve, reject]);\r\n        });\r\n    }\r\n    /**\r\n     * Mark the router as ready, resolving the promised returned by isReady(). Can\r\n     * only be called once, otherwise does nothing.\r\n     * @param err - optional error\r\n     */\r\n    function markAsReady(err) {\r\n        if (ready)\r\n            return;\r\n        ready = true;\r\n        setupListeners();\r\n        readyHandlers\r\n            .list()\r\n            .forEach(([resolve, reject]) => (err ? reject(err) : resolve()));\r\n        readyHandlers.reset();\r\n    }\r\n    // Scroll behavior\r\n    function handleScroll(to, from, isPush, isFirstNavigation) {\r\n        const { scrollBehavior } = options;\r\n        if (!isBrowser || !scrollBehavior)\r\n            return Promise.resolve();\r\n        let scrollPosition = (!isPush && getSavedScrollPosition(getScrollKey(to.fullPath, 0))) ||\r\n            ((isFirstNavigation || !isPush) &&\r\n                history.state &&\r\n                history.state.scroll) ||\r\n            null;\r\n        return nextTick()\r\n            .then(() => scrollBehavior(to, from, scrollPosition))\r\n            .then(position => position && scrollToPosition(position))\r\n            .catch(triggerError);\r\n    }\r\n    const go = (delta) => routerHistory.go(delta);\r\n    let started;\r\n    const installedApps = new Set();\r\n    const router = {\r\n        currentRoute,\r\n        addRoute,\r\n        removeRoute,\r\n        hasRoute,\r\n        getRoutes,\r\n        resolve,\r\n        options,\r\n        push,\r\n        replace,\r\n        go,\r\n        back: () => go(-1),\r\n        forward: () => go(1),\r\n        beforeEach: beforeGuards.add,\r\n        beforeResolve: beforeResolveGuards.add,\r\n        afterEach: afterGuards.add,\r\n        onError: errorHandlers.add,\r\n        isReady,\r\n        install(app) {\r\n            const router = this;\r\n            app.component('RouterLink', RouterLink);\r\n            app.component('RouterView', RouterView);\r\n            app.config.globalProperties.$router = router;\r\n            Object.defineProperty(app.config.globalProperties, '$route', {\r\n                enumerable: true,\r\n                get: () => unref(currentRoute),\r\n            });\r\n            // this initial navigation is only necessary on client, on server it doesn't\r\n            // make sense because it will create an extra unnecessary navigation and could\r\n            // lead to problems\r\n            if (isBrowser &&\r\n                // used for the initial navigation client side to avoid pushing\r\n                // multiple times when the router is used in multiple apps\r\n                !started &&\r\n                currentRoute.value === START_LOCATION_NORMALIZED) {\r\n                // see above\r\n                started = true;\r\n                push(routerHistory.location).catch(err => {\r\n                    if ((process.env.NODE_ENV !== 'production'))\r\n                        warn('Unexpected error when starting the router:', err);\r\n                });\r\n            }\r\n            const reactiveRoute = {};\r\n            for (let key in START_LOCATION_NORMALIZED) {\r\n                // @ts-ignore: the key matches\r\n                reactiveRoute[key] = computed(() => currentRoute.value[key]);\r\n            }\r\n            app.provide(routerKey, router);\r\n            app.provide(routeLocationKey, reactive(reactiveRoute));\r\n            app.provide(routerViewLocationKey, currentRoute);\r\n            let unmountApp = app.unmount;\r\n            installedApps.add(app);\r\n            app.unmount = function () {\r\n                installedApps.delete(app);\r\n                if (installedApps.size < 1) {\r\n                    removeHistoryListener();\r\n                    currentRoute.value = START_LOCATION_NORMALIZED;\r\n                    started = false;\r\n                    ready = false;\r\n                }\r\n                unmountApp();\r\n            };\r\n            if (((process.env.NODE_ENV !== 'production') || __VUE_PROD_DEVTOOLS__) && isBrowser) {\r\n                addDevtools(app, router, matcher);\r\n            }\r\n        },\r\n    };\r\n    return router;\r\n}\r\nfunction runGuardQueue(guards) {\r\n    return guards.reduce((promise, guard) => promise.then(() => guard()), Promise.resolve());\r\n}\r\nfunction extractChangingRecords(to, from) {\r\n    const leavingRecords = [];\r\n    const updatingRecords = [];\r\n    const enteringRecords = [];\r\n    const len = Math.max(from.matched.length, to.matched.length);\r\n    for (let i = 0; i < len; i++) {\r\n        const recordFrom = from.matched[i];\r\n        if (recordFrom) {\r\n            if (to.matched.find(record => isSameRouteRecord(record, recordFrom)))\r\n                updatingRecords.push(recordFrom);\r\n            else\r\n                leavingRecords.push(recordFrom);\r\n        }\r\n        const recordTo = to.matched[i];\r\n        if (recordTo) {\r\n            // the type doesn't matter because we are comparing per reference\r\n            if (!from.matched.find(record => isSameRouteRecord(record, recordTo))) {\r\n                enteringRecords.push(recordTo);\r\n            }\r\n        }\r\n    }\r\n    return [leavingRecords, updatingRecords, enteringRecords];\r\n}\n\n/**\r\n * Returns the router instance. Equivalent to using `$router` inside\r\n * templates.\r\n */\r\nfunction useRouter() {\r\n    return inject(routerKey);\r\n}\r\n/**\r\n * Returns the current route location. Equivalent to using `$route` inside\r\n * templates.\r\n */\r\nfunction useRoute() {\r\n    return inject(routeLocationKey);\r\n}\n\nexport { NavigationFailureType, RouterLink, RouterView, START_LOCATION_NORMALIZED as START_LOCATION, createMemoryHistory, createRouter, createRouterMatcher, createWebHashHistory, createWebHistory, isNavigationFailure, matchedRouteKey, onBeforeRouteLeave, onBeforeRouteUpdate, parseQuery, routeLocationKey, routerKey, routerViewLocationKey, stringifyQuery, useLink, useRoute, useRouter, viewDepthKey };\n","let scriptRel;const seen = {};export const __vitePreload = function preload(baseModule, deps) {\n    // @ts-ignore\n    if (!__VITE_IS_MODERN__ || !deps) {\n        return baseModule();\n    }\n    // @ts-ignore\n    if (scriptRel === undefined) {\n        // @ts-ignore\n        const relList = document.createElement('link').relList;\n        // @ts-ignore\n        scriptRel =\n            relList && relList.supports && relList.supports('modulepreload')\n                ? 'modulepreload'\n                : 'preload';\n    }\n    return Promise.all(deps.map((dep) => {\n        // @ts-ignore\n        if (dep in seen)\n            return;\n        // @ts-ignore\n        seen[dep] = true;\n        const isCss = dep.endsWith('.css');\n        const cssSelector = isCss ? '[rel=\"stylesheet\"]' : '';\n        // @ts-ignore check if the file is already preloaded by SSR markup\n        if (document.querySelector(`link[href=\"${dep}\"]${cssSelector}`)) {\n            return;\n        }\n        // @ts-ignore\n        const link = document.createElement('link');\n        // @ts-ignore\n        link.rel = isCss ? 'stylesheet' : scriptRel;\n        if (!isCss) {\n            link.as = 'script';\n            link.crossOrigin = '';\n        }\n        link.href = dep;\n        // @ts-ignore\n        document.head.appendChild(link);\n        if (isCss) {\n            return new Promise((res, rej) => {\n                link.addEventListener('load', res);\n                link.addEventListener('error', rej);\n            });\n        }\n    })).then(() => baseModule());\n}","export default [\r\n  {\r\n    path: '/',\r\n    redirect: '/light/login'\r\n  },\r\n  {\r\n    path: \"/light/login\",\r\n    component: () => import(\"../views/light/login/Login.vue\"),\r\n  },\r\n  {\r\n    path: '/light/index',\r\n    component: () => import('../views/light/index/Index.vue'),\r\n    children: [\r\n      {\r\n        path: '/light/index/home',\r\n        component: () => import('../views/light/index/home/Home.vue')\r\n      }\r\n    ]\r\n  }\r\n]","import { createRouter, createWebHistory, createWebHashHistory } from \"vue-router\"\r\nimport light from './light'\r\n\r\nconst router = createRouter({\r\n  history: createWebHashHistory(),\r\n  routes: [...light],\r\n})\r\n\r\nexport default router\r\n","const urls = {\r\n  login: '/api/login',\r\n  list: '/api/list',\r\n  myBooks: '/api/my_books',\r\n  detail: '/api/detail/'\r\n}\r\n\r\nexport default urls","import lightUrls from \"./lightUrls\"\r\n\r\nconst urls = {\r\n  light: lightUrls,\r\n}\r\n\r\nexport default urls\r\n","'use strict';\n\nmodule.exports = function bind(fn, thisArg) {\n  return function wrap() {\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n    return fn.apply(thisArg, args);\n  };\n};\n","'use strict';\n\nvar bind = require('./helpers/bind');\n\n/*global toString:true*/\n\n// utils is a library of generic helper functions non-specific to axios\n\nvar toString = Object.prototype.toString;\n\n/**\n * Determine if a value is an Array\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Array, otherwise false\n */\nfunction isArray(val) {\n  return toString.call(val) === '[object Array]';\n}\n\n/**\n * Determine if a value is undefined\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if the value is undefined, otherwise false\n */\nfunction isUndefined(val) {\n  return typeof val === 'undefined';\n}\n\n/**\n * Determine if a value is a Buffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Buffer, otherwise false\n */\nfunction isBuffer(val) {\n  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)\n    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);\n}\n\n/**\n * Determine if a value is an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an ArrayBuffer, otherwise false\n */\nfunction isArrayBuffer(val) {\n  return toString.call(val) === '[object ArrayBuffer]';\n}\n\n/**\n * Determine if a value is a FormData\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an FormData, otherwise false\n */\nfunction isFormData(val) {\n  return (typeof FormData !== 'undefined') && (val instanceof FormData);\n}\n\n/**\n * Determine if a value is a view on an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false\n */\nfunction isArrayBufferView(val) {\n  var result;\n  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {\n    result = ArrayBuffer.isView(val);\n  } else {\n    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);\n  }\n  return result;\n}\n\n/**\n * Determine if a value is a String\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a String, otherwise false\n */\nfunction isString(val) {\n  return typeof val === 'string';\n}\n\n/**\n * Determine if a value is a Number\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Number, otherwise false\n */\nfunction isNumber(val) {\n  return typeof val === 'number';\n}\n\n/**\n * Determine if a value is an Object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Object, otherwise false\n */\nfunction isObject(val) {\n  return val !== null && typeof val === 'object';\n}\n\n/**\n * Determine if a value is a plain Object\n *\n * @param {Object} val The value to test\n * @return {boolean} True if value is a plain Object, otherwise false\n */\nfunction isPlainObject(val) {\n  if (toString.call(val) !== '[object Object]') {\n    return false;\n  }\n\n  var prototype = Object.getPrototypeOf(val);\n  return prototype === null || prototype === Object.prototype;\n}\n\n/**\n * Determine if a value is a Date\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Date, otherwise false\n */\nfunction isDate(val) {\n  return toString.call(val) === '[object Date]';\n}\n\n/**\n * Determine if a value is a File\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a File, otherwise false\n */\nfunction isFile(val) {\n  return toString.call(val) === '[object File]';\n}\n\n/**\n * Determine if a value is a Blob\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Blob, otherwise false\n */\nfunction isBlob(val) {\n  return toString.call(val) === '[object Blob]';\n}\n\n/**\n * Determine if a value is a Function\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Function, otherwise false\n */\nfunction isFunction(val) {\n  return toString.call(val) === '[object Function]';\n}\n\n/**\n * Determine if a value is a Stream\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Stream, otherwise false\n */\nfunction isStream(val) {\n  return isObject(val) && isFunction(val.pipe);\n}\n\n/**\n * Determine if a value is a URLSearchParams object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a URLSearchParams object, otherwise false\n */\nfunction isURLSearchParams(val) {\n  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;\n}\n\n/**\n * Trim excess whitespace off the beginning and end of a string\n *\n * @param {String} str The String to trim\n * @returns {String} The String freed of excess whitespace\n */\nfunction trim(str) {\n  return str.replace(/^\\s*/, '').replace(/\\s*$/, '');\n}\n\n/**\n * Determine if we're running in a standard browser environment\n *\n * This allows axios to run in a web worker, and react-native.\n * Both environments support XMLHttpRequest, but not fully standard globals.\n *\n * web workers:\n *  typeof window -> undefined\n *  typeof document -> undefined\n *\n * react-native:\n *  navigator.product -> 'ReactNative'\n * nativescript\n *  navigator.product -> 'NativeScript' or 'NS'\n */\nfunction isStandardBrowserEnv() {\n  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||\n                                           navigator.product === 'NativeScript' ||\n                                           navigator.product === 'NS')) {\n    return false;\n  }\n  return (\n    typeof window !== 'undefined' &&\n    typeof document !== 'undefined'\n  );\n}\n\n/**\n * Iterate over an Array or an Object invoking a function for each item.\n *\n * If `obj` is an Array callback will be called passing\n * the value, index, and complete array for each item.\n *\n * If 'obj' is an Object callback will be called passing\n * the value, key, and complete object for each property.\n *\n * @param {Object|Array} obj The object to iterate\n * @param {Function} fn The callback to invoke for each item\n */\nfunction forEach(obj, fn) {\n  // Don't bother if no value provided\n  if (obj === null || typeof obj === 'undefined') {\n    return;\n  }\n\n  // Force an array if not already something iterable\n  if (typeof obj !== 'object') {\n    /*eslint no-param-reassign:0*/\n    obj = [obj];\n  }\n\n  if (isArray(obj)) {\n    // Iterate over array values\n    for (var i = 0, l = obj.length; i < l; i++) {\n      fn.call(null, obj[i], i, obj);\n    }\n  } else {\n    // Iterate over object keys\n    for (var key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        fn.call(null, obj[key], key, obj);\n      }\n    }\n  }\n}\n\n/**\n * Accepts varargs expecting each argument to be an object, then\n * immutably merges the properties of each object and returns result.\n *\n * When multiple objects contain the same key the later object in\n * the arguments list will take precedence.\n *\n * Example:\n *\n * ```js\n * var result = merge({foo: 123}, {foo: 456});\n * console.log(result.foo); // outputs 456\n * ```\n *\n * @param {Object} obj1 Object to merge\n * @returns {Object} Result of all merge properties\n */\nfunction merge(/* obj1, obj2, obj3, ... */) {\n  var result = {};\n  function assignValue(val, key) {\n    if (isPlainObject(result[key]) && isPlainObject(val)) {\n      result[key] = merge(result[key], val);\n    } else if (isPlainObject(val)) {\n      result[key] = merge({}, val);\n    } else if (isArray(val)) {\n      result[key] = val.slice();\n    } else {\n      result[key] = val;\n    }\n  }\n\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    forEach(arguments[i], assignValue);\n  }\n  return result;\n}\n\n/**\n * Extends object a by mutably adding to it the properties of object b.\n *\n * @param {Object} a The object to be extended\n * @param {Object} b The object to copy properties from\n * @param {Object} thisArg The object to bind function to\n * @return {Object} The resulting value of object a\n */\nfunction extend(a, b, thisArg) {\n  forEach(b, function assignValue(val, key) {\n    if (thisArg && typeof val === 'function') {\n      a[key] = bind(val, thisArg);\n    } else {\n      a[key] = val;\n    }\n  });\n  return a;\n}\n\n/**\n * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n *\n * @param {string} content with BOM\n * @return {string} content value without BOM\n */\nfunction stripBOM(content) {\n  if (content.charCodeAt(0) === 0xFEFF) {\n    content = content.slice(1);\n  }\n  return content;\n}\n\nmodule.exports = {\n  isArray: isArray,\n  isArrayBuffer: isArrayBuffer,\n  isBuffer: isBuffer,\n  isFormData: isFormData,\n  isArrayBufferView: isArrayBufferView,\n  isString: isString,\n  isNumber: isNumber,\n  isObject: isObject,\n  isPlainObject: isPlainObject,\n  isUndefined: isUndefined,\n  isDate: isDate,\n  isFile: isFile,\n  isBlob: isBlob,\n  isFunction: isFunction,\n  isStream: isStream,\n  isURLSearchParams: isURLSearchParams,\n  isStandardBrowserEnv: isStandardBrowserEnv,\n  forEach: forEach,\n  merge: merge,\n  extend: extend,\n  trim: trim,\n  stripBOM: stripBOM\n};\n","'use strict';\n\nvar utils = require('./../utils');\n\nfunction encode(val) {\n  return encodeURIComponent(val).\n    replace(/%3A/gi, ':').\n    replace(/%24/g, '$').\n    replace(/%2C/gi, ',').\n    replace(/%20/g, '+').\n    replace(/%5B/gi, '[').\n    replace(/%5D/gi, ']');\n}\n\n/**\n * Build a URL by appending params to the end\n *\n * @param {string} url The base of the url (e.g., http://www.google.com)\n * @param {object} [params] The params to be appended\n * @returns {string} The formatted url\n */\nmodule.exports = function buildURL(url, params, paramsSerializer) {\n  /*eslint no-param-reassign:0*/\n  if (!params) {\n    return url;\n  }\n\n  var serializedParams;\n  if (paramsSerializer) {\n    serializedParams = paramsSerializer(params);\n  } else if (utils.isURLSearchParams(params)) {\n    serializedParams = params.toString();\n  } else {\n    var parts = [];\n\n    utils.forEach(params, function serialize(val, key) {\n      if (val === null || typeof val === 'undefined') {\n        return;\n      }\n\n      if (utils.isArray(val)) {\n        key = key + '[]';\n      } else {\n        val = [val];\n      }\n\n      utils.forEach(val, function parseValue(v) {\n        if (utils.isDate(v)) {\n          v = v.toISOString();\n        } else if (utils.isObject(v)) {\n          v = JSON.stringify(v);\n        }\n        parts.push(encode(key) + '=' + encode(v));\n      });\n    });\n\n    serializedParams = parts.join('&');\n  }\n\n  if (serializedParams) {\n    var hashmarkIndex = url.indexOf('#');\n    if (hashmarkIndex !== -1) {\n      url = url.slice(0, hashmarkIndex);\n    }\n\n    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;\n  }\n\n  return url;\n};\n","'use strict';\n\nvar utils = require('./../utils');\n\nfunction InterceptorManager() {\n  this.handlers = [];\n}\n\n/**\n * Add a new interceptor to the stack\n *\n * @param {Function} fulfilled The function to handle `then` for a `Promise`\n * @param {Function} rejected The function to handle `reject` for a `Promise`\n *\n * @return {Number} An ID used to remove interceptor later\n */\nInterceptorManager.prototype.use = function use(fulfilled, rejected) {\n  this.handlers.push({\n    fulfilled: fulfilled,\n    rejected: rejected\n  });\n  return this.handlers.length - 1;\n};\n\n/**\n * Remove an interceptor from the stack\n *\n * @param {Number} id The ID that was returned by `use`\n */\nInterceptorManager.prototype.eject = function eject(id) {\n  if (this.handlers[id]) {\n    this.handlers[id] = null;\n  }\n};\n\n/**\n * Iterate over all the registered interceptors\n *\n * This method is particularly useful for skipping over any\n * interceptors that may have become `null` calling `eject`.\n *\n * @param {Function} fn The function to call for each interceptor\n */\nInterceptorManager.prototype.forEach = function forEach(fn) {\n  utils.forEach(this.handlers, function forEachHandler(h) {\n    if (h !== null) {\n      fn(h);\n    }\n  });\n};\n\nmodule.exports = InterceptorManager;\n","'use strict';\n\nvar utils = require('./../utils');\n\n/**\n * Transform the data for a request or a response\n *\n * @param {Object|String} data The data to be transformed\n * @param {Array} headers The headers for the request or response\n * @param {Array|Function} fns A single function or Array of functions\n * @returns {*} The resulting transformed data\n */\nmodule.exports = function transformData(data, headers, fns) {\n  /*eslint no-param-reassign:0*/\n  utils.forEach(fns, function transform(fn) {\n    data = fn(data, headers);\n  });\n\n  return data;\n};\n","'use strict';\n\nmodule.exports = function isCancel(value) {\n  return !!(value && value.__CANCEL__);\n};\n","'use strict';\n\nvar utils = require('../utils');\n\nmodule.exports = function normalizeHeaderName(headers, normalizedName) {\n  utils.forEach(headers, function processHeader(value, name) {\n    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {\n      headers[normalizedName] = value;\n      delete headers[name];\n    }\n  });\n};\n","'use strict';\n\nvar enhanceError = require('./enhanceError');\n\n/**\n * Create an Error with the specified message, config, error code, request and response.\n *\n * @param {string} message The error message.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The created error.\n */\nmodule.exports = function createError(message, config, code, request, response) {\n  var error = new Error(message);\n  return enhanceError(error, config, code, request, response);\n};\n","'use strict';\n\n/**\n * Update an Error with the specified config, error code, and response.\n *\n * @param {Error} error The error to update.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The error.\n */\nmodule.exports = function enhanceError(error, config, code, request, response) {\n  error.config = config;\n  if (code) {\n    error.code = code;\n  }\n\n  error.request = request;\n  error.response = response;\n  error.isAxiosError = true;\n\n  error.toJSON = function toJSON() {\n    return {\n      // Standard\n      message: this.message,\n      name: this.name,\n      // Microsoft\n      description: this.description,\n      number: this.number,\n      // Mozilla\n      fileName: this.fileName,\n      lineNumber: this.lineNumber,\n      columnNumber: this.columnNumber,\n      stack: this.stack,\n      // Axios\n      config: this.config,\n      code: this.code\n    };\n  };\n  return error;\n};\n","'use strict';\n\nvar utils = require('./../utils');\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs support document.cookie\n    (function standardBrowserEnv() {\n      return {\n        write: function write(name, value, expires, path, domain, secure) {\n          var cookie = [];\n          cookie.push(name + '=' + encodeURIComponent(value));\n\n          if (utils.isNumber(expires)) {\n            cookie.push('expires=' + new Date(expires).toGMTString());\n          }\n\n          if (utils.isString(path)) {\n            cookie.push('path=' + path);\n          }\n\n          if (utils.isString(domain)) {\n            cookie.push('domain=' + domain);\n          }\n\n          if (secure === true) {\n            cookie.push('secure');\n          }\n\n          document.cookie = cookie.join('; ');\n        },\n\n        read: function read(name) {\n          var match = document.cookie.match(new RegExp('(^|;\\\\s*)(' + name + ')=([^;]*)'));\n          return (match ? decodeURIComponent(match[3]) : null);\n        },\n\n        remove: function remove(name) {\n          this.write(name, '', Date.now() - 86400000);\n        }\n      };\n    })() :\n\n  // Non standard browser env (web workers, react-native) lack needed support.\n    (function nonStandardBrowserEnv() {\n      return {\n        write: function write() {},\n        read: function read() { return null; },\n        remove: function remove() {}\n      };\n    })()\n);\n","'use strict';\n\nvar utils = require('./../utils');\n\n// Headers whose duplicates are ignored by node\n// c.f. https://nodejs.org/api/http.html#http_message_headers\nvar ignoreDuplicateOf = [\n  'age', 'authorization', 'content-length', 'content-type', 'etag',\n  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',\n  'last-modified', 'location', 'max-forwards', 'proxy-authorization',\n  'referer', 'retry-after', 'user-agent'\n];\n\n/**\n * Parse headers into an object\n *\n * ```\n * Date: Wed, 27 Aug 2014 08:58:49 GMT\n * Content-Type: application/json\n * Connection: keep-alive\n * Transfer-Encoding: chunked\n * ```\n *\n * @param {String} headers Headers needing to be parsed\n * @returns {Object} Headers parsed into an object\n */\nmodule.exports = function parseHeaders(headers) {\n  var parsed = {};\n  var key;\n  var val;\n  var i;\n\n  if (!headers) { return parsed; }\n\n  utils.forEach(headers.split('\\n'), function parser(line) {\n    i = line.indexOf(':');\n    key = utils.trim(line.substr(0, i)).toLowerCase();\n    val = utils.trim(line.substr(i + 1));\n\n    if (key) {\n      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {\n        return;\n      }\n      if (key === 'set-cookie') {\n        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);\n      } else {\n        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;\n      }\n    }\n  });\n\n  return parsed;\n};\n","'use strict';\n\nvar utils = require('./../utils');\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs have full support of the APIs needed to test\n  // whether the request URL is of the same origin as current location.\n    (function standardBrowserEnv() {\n      var msie = /(msie|trident)/i.test(navigator.userAgent);\n      var urlParsingNode = document.createElement('a');\n      var originURL;\n\n      /**\n    * Parse a URL to discover it's components\n    *\n    * @param {String} url The URL to be parsed\n    * @returns {Object}\n    */\n      function resolveURL(url) {\n        var href = url;\n\n        if (msie) {\n        // IE needs attribute set twice to normalize properties\n          urlParsingNode.setAttribute('href', href);\n          href = urlParsingNode.href;\n        }\n\n        urlParsingNode.setAttribute('href', href);\n\n        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils\n        return {\n          href: urlParsingNode.href,\n          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',\n          host: urlParsingNode.host,\n          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\\?/, '') : '',\n          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',\n          hostname: urlParsingNode.hostname,\n          port: urlParsingNode.port,\n          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?\n            urlParsingNode.pathname :\n            '/' + urlParsingNode.pathname\n        };\n      }\n\n      originURL = resolveURL(window.location.href);\n\n      /**\n    * Determine if a URL shares the same origin as the current location\n    *\n    * @param {String} requestURL The URL to test\n    * @returns {boolean} True if URL shares the same origin, otherwise false\n    */\n      return function isURLSameOrigin(requestURL) {\n        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;\n        return (parsed.protocol === originURL.protocol &&\n            parsed.host === originURL.host);\n      };\n    })() :\n\n  // Non standard browser envs (web workers, react-native) lack needed support.\n    (function nonStandardBrowserEnv() {\n      return function isURLSameOrigin() {\n        return true;\n      };\n    })()\n);\n","'use strict';\n\nvar utils = require('./../utils');\nvar settle = require('./../core/settle');\nvar cookies = require('./../helpers/cookies');\nvar buildURL = require('./../helpers/buildURL');\nvar buildFullPath = require('../core/buildFullPath');\nvar parseHeaders = require('./../helpers/parseHeaders');\nvar isURLSameOrigin = require('./../helpers/isURLSameOrigin');\nvar createError = require('../core/createError');\n\nmodule.exports = function xhrAdapter(config) {\n  return new Promise(function dispatchXhrRequest(resolve, reject) {\n    var requestData = config.data;\n    var requestHeaders = config.headers;\n\n    if (utils.isFormData(requestData)) {\n      delete requestHeaders['Content-Type']; // Let the browser set it\n    }\n\n    var request = new XMLHttpRequest();\n\n    // HTTP basic authentication\n    if (config.auth) {\n      var username = config.auth.username || '';\n      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';\n      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);\n    }\n\n    var fullPath = buildFullPath(config.baseURL, config.url);\n    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);\n\n    // Set the request timeout in MS\n    request.timeout = config.timeout;\n\n    // Listen for ready state\n    request.onreadystatechange = function handleLoad() {\n      if (!request || request.readyState !== 4) {\n        return;\n      }\n\n      // The request errored out and we didn't get a response, this will be\n      // handled by onerror instead\n      // With one exception: request that using file: protocol, most browsers\n      // will return status as 0 even though it's a successful request\n      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {\n        return;\n      }\n\n      // Prepare the response\n      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;\n      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;\n      var response = {\n        data: responseData,\n        status: request.status,\n        statusText: request.statusText,\n        headers: responseHeaders,\n        config: config,\n        request: request\n      };\n\n      settle(resolve, reject, response);\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle browser request cancellation (as opposed to a manual cancellation)\n    request.onabort = function handleAbort() {\n      if (!request) {\n        return;\n      }\n\n      reject(createError('Request aborted', config, 'ECONNABORTED', request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle low level network errors\n    request.onerror = function handleError() {\n      // Real errors are hidden from us by the browser\n      // onerror should only fire if it's a network error\n      reject(createError('Network Error', config, null, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle timeout\n    request.ontimeout = function handleTimeout() {\n      var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';\n      if (config.timeoutErrorMessage) {\n        timeoutErrorMessage = config.timeoutErrorMessage;\n      }\n      reject(createError(timeoutErrorMessage, config, 'ECONNABORTED',\n        request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Add xsrf header\n    // This is only done if running in a standard browser environment.\n    // Specifically not if we're in a web worker, or react-native.\n    if (utils.isStandardBrowserEnv()) {\n      // Add xsrf header\n      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?\n        cookies.read(config.xsrfCookieName) :\n        undefined;\n\n      if (xsrfValue) {\n        requestHeaders[config.xsrfHeaderName] = xsrfValue;\n      }\n    }\n\n    // Add headers to the request\n    if ('setRequestHeader' in request) {\n      utils.forEach(requestHeaders, function setRequestHeader(val, key) {\n        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {\n          // Remove Content-Type if data is undefined\n          delete requestHeaders[key];\n        } else {\n          // Otherwise add header to the request\n          request.setRequestHeader(key, val);\n        }\n      });\n    }\n\n    // Add withCredentials to request if needed\n    if (!utils.isUndefined(config.withCredentials)) {\n      request.withCredentials = !!config.withCredentials;\n    }\n\n    // Add responseType to request if needed\n    if (config.responseType) {\n      try {\n        request.responseType = config.responseType;\n      } catch (e) {\n        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.\n        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.\n        if (config.responseType !== 'json') {\n          throw e;\n        }\n      }\n    }\n\n    // Handle progress if needed\n    if (typeof config.onDownloadProgress === 'function') {\n      request.addEventListener('progress', config.onDownloadProgress);\n    }\n\n    // Not all browsers support upload events\n    if (typeof config.onUploadProgress === 'function' && request.upload) {\n      request.upload.addEventListener('progress', config.onUploadProgress);\n    }\n\n    if (config.cancelToken) {\n      // Handle cancellation\n      config.cancelToken.promise.then(function onCanceled(cancel) {\n        if (!request) {\n          return;\n        }\n\n        request.abort();\n        reject(cancel);\n        // Clean up request\n        request = null;\n      });\n    }\n\n    if (!requestData) {\n      requestData = null;\n    }\n\n    // Send the request\n    request.send(requestData);\n  });\n};\n","'use strict';\n\nvar isAbsoluteURL = require('../helpers/isAbsoluteURL');\nvar combineURLs = require('../helpers/combineURLs');\n\n/**\n * Creates a new URL by combining the baseURL with the requestedURL,\n * only when the requestedURL is not already an absolute URL.\n * If the requestURL is absolute, this function returns the requestedURL untouched.\n *\n * @param {string} baseURL The base URL\n * @param {string} requestedURL Absolute or relative URL to combine\n * @returns {string} The combined full path\n */\nmodule.exports = function buildFullPath(baseURL, requestedURL) {\n  if (baseURL && !isAbsoluteURL(requestedURL)) {\n    return combineURLs(baseURL, requestedURL);\n  }\n  return requestedURL;\n};\n","'use strict';\n\n/**\n * Determines whether the specified URL is absolute\n *\n * @param {string} url The URL to test\n * @returns {boolean} True if the specified URL is absolute, otherwise false\n */\nmodule.exports = function isAbsoluteURL(url) {\n  // A URL is considered absolute if it begins with \"<scheme>://\" or \"//\" (protocol-relative URL).\n  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed\n  // by any combination of letters, digits, plus, period, or hyphen.\n  return /^([a-z][a-z\\d\\+\\-\\.]*:)?\\/\\//i.test(url);\n};\n","'use strict';\n\n/**\n * Creates a new URL by combining the specified URLs\n *\n * @param {string} baseURL The base URL\n * @param {string} relativeURL The relative URL\n * @returns {string} The combined URL\n */\nmodule.exports = function combineURLs(baseURL, relativeURL) {\n  return relativeURL\n    ? baseURL.replace(/\\/+$/, '') + '/' + relativeURL.replace(/^\\/+/, '')\n    : baseURL;\n};\n","'use strict';\n\nvar createError = require('./createError');\n\n/**\n * Resolve or reject a Promise based on response status.\n *\n * @param {Function} resolve A function that resolves the promise.\n * @param {Function} reject A function that rejects the promise.\n * @param {object} response The response.\n */\nmodule.exports = function settle(resolve, reject, response) {\n  var validateStatus = response.config.validateStatus;\n  if (!response.status || !validateStatus || validateStatus(response.status)) {\n    resolve(response);\n  } else {\n    reject(createError(\n      'Request failed with status code ' + response.status,\n      response.config,\n      null,\n      response.request,\n      response\n    ));\n  }\n};\n","'use strict';\n\nvar utils = require('./utils');\nvar normalizeHeaderName = require('./helpers/normalizeHeaderName');\n\nvar DEFAULT_CONTENT_TYPE = {\n  'Content-Type': 'application/x-www-form-urlencoded'\n};\n\nfunction setContentTypeIfUnset(headers, value) {\n  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {\n    headers['Content-Type'] = value;\n  }\n}\n\nfunction getDefaultAdapter() {\n  var adapter;\n  if (typeof XMLHttpRequest !== 'undefined') {\n    // For browsers use XHR adapter\n    adapter = require('./adapters/xhr');\n  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {\n    // For node use HTTP adapter\n    adapter = require('./adapters/http');\n  }\n  return adapter;\n}\n\nvar defaults = {\n  adapter: getDefaultAdapter(),\n\n  transformRequest: [function transformRequest(data, headers) {\n    normalizeHeaderName(headers, 'Accept');\n    normalizeHeaderName(headers, 'Content-Type');\n    if (utils.isFormData(data) ||\n      utils.isArrayBuffer(data) ||\n      utils.isBuffer(data) ||\n      utils.isStream(data) ||\n      utils.isFile(data) ||\n      utils.isBlob(data)\n    ) {\n      return data;\n    }\n    if (utils.isArrayBufferView(data)) {\n      return data.buffer;\n    }\n    if (utils.isURLSearchParams(data)) {\n      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');\n      return data.toString();\n    }\n    if (utils.isObject(data)) {\n      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');\n      return JSON.stringify(data);\n    }\n    return data;\n  }],\n\n  transformResponse: [function transformResponse(data) {\n    /*eslint no-param-reassign:0*/\n    if (typeof data === 'string') {\n      try {\n        data = JSON.parse(data);\n      } catch (e) { /* Ignore */ }\n    }\n    return data;\n  }],\n\n  /**\n   * A timeout in milliseconds to abort a request. If set to 0 (default) a\n   * timeout is not created.\n   */\n  timeout: 0,\n\n  xsrfCookieName: 'XSRF-TOKEN',\n  xsrfHeaderName: 'X-XSRF-TOKEN',\n\n  maxContentLength: -1,\n  maxBodyLength: -1,\n\n  validateStatus: function validateStatus(status) {\n    return status >= 200 && status < 300;\n  }\n};\n\ndefaults.headers = {\n  common: {\n    'Accept': 'application/json, text/plain, */*'\n  }\n};\n\nutils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {\n  defaults.headers[method] = {};\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);\n});\n\nmodule.exports = defaults;\n","'use strict';\n\nvar utils = require('./../utils');\nvar transformData = require('./transformData');\nvar isCancel = require('../cancel/isCancel');\nvar defaults = require('../defaults');\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nfunction throwIfCancellationRequested(config) {\n  if (config.cancelToken) {\n    config.cancelToken.throwIfRequested();\n  }\n}\n\n/**\n * Dispatch a request to the server using the configured adapter.\n *\n * @param {object} config The config that is to be used for the request\n * @returns {Promise} The Promise to be fulfilled\n */\nmodule.exports = function dispatchRequest(config) {\n  throwIfCancellationRequested(config);\n\n  // Ensure headers exist\n  config.headers = config.headers || {};\n\n  // Transform request data\n  config.data = transformData(\n    config.data,\n    config.headers,\n    config.transformRequest\n  );\n\n  // Flatten headers\n  config.headers = utils.merge(\n    config.headers.common || {},\n    config.headers[config.method] || {},\n    config.headers\n  );\n\n  utils.forEach(\n    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],\n    function cleanHeaderConfig(method) {\n      delete config.headers[method];\n    }\n  );\n\n  var adapter = config.adapter || defaults.adapter;\n\n  return adapter(config).then(function onAdapterResolution(response) {\n    throwIfCancellationRequested(config);\n\n    // Transform response data\n    response.data = transformData(\n      response.data,\n      response.headers,\n      config.transformResponse\n    );\n\n    return response;\n  }, function onAdapterRejection(reason) {\n    if (!isCancel(reason)) {\n      throwIfCancellationRequested(config);\n\n      // Transform response data\n      if (reason && reason.response) {\n        reason.response.data = transformData(\n          reason.response.data,\n          reason.response.headers,\n          config.transformResponse\n        );\n      }\n    }\n\n    return Promise.reject(reason);\n  });\n};\n","'use strict';\n\nvar utils = require('../utils');\n\n/**\n * Config-specific merge-function which creates a new config-object\n * by merging two configuration objects together.\n *\n * @param {Object} config1\n * @param {Object} config2\n * @returns {Object} New object resulting from merging config2 to config1\n */\nmodule.exports = function mergeConfig(config1, config2) {\n  // eslint-disable-next-line no-param-reassign\n  config2 = config2 || {};\n  var config = {};\n\n  var valueFromConfig2Keys = ['url', 'method', 'data'];\n  var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy', 'params'];\n  var defaultToConfig2Keys = [\n    'baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer',\n    'timeout', 'timeoutMessage', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName',\n    'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'decompress',\n    'maxContentLength', 'maxBodyLength', 'maxRedirects', 'transport', 'httpAgent',\n    'httpsAgent', 'cancelToken', 'socketPath', 'responseEncoding'\n  ];\n  var directMergeKeys = ['validateStatus'];\n\n  function getMergedValue(target, source) {\n    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {\n      return utils.merge(target, source);\n    } else if (utils.isPlainObject(source)) {\n      return utils.merge({}, source);\n    } else if (utils.isArray(source)) {\n      return source.slice();\n    }\n    return source;\n  }\n\n  function mergeDeepProperties(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      config[prop] = getMergedValue(config1[prop], config2[prop]);\n    } else if (!utils.isUndefined(config1[prop])) {\n      config[prop] = getMergedValue(undefined, config1[prop]);\n    }\n  }\n\n  utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      config[prop] = getMergedValue(undefined, config2[prop]);\n    }\n  });\n\n  utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);\n\n  utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      config[prop] = getMergedValue(undefined, config2[prop]);\n    } else if (!utils.isUndefined(config1[prop])) {\n      config[prop] = getMergedValue(undefined, config1[prop]);\n    }\n  });\n\n  utils.forEach(directMergeKeys, function merge(prop) {\n    if (prop in config2) {\n      config[prop] = getMergedValue(config1[prop], config2[prop]);\n    } else if (prop in config1) {\n      config[prop] = getMergedValue(undefined, config1[prop]);\n    }\n  });\n\n  var axiosKeys = valueFromConfig2Keys\n    .concat(mergeDeepPropertiesKeys)\n    .concat(defaultToConfig2Keys)\n    .concat(directMergeKeys);\n\n  var otherKeys = Object\n    .keys(config1)\n    .concat(Object.keys(config2))\n    .filter(function filterAxiosKeys(key) {\n      return axiosKeys.indexOf(key) === -1;\n    });\n\n  utils.forEach(otherKeys, mergeDeepProperties);\n\n  return config;\n};\n","'use strict';\n\nvar utils = require('./../utils');\nvar buildURL = require('../helpers/buildURL');\nvar InterceptorManager = require('./InterceptorManager');\nvar dispatchRequest = require('./dispatchRequest');\nvar mergeConfig = require('./mergeConfig');\n\n/**\n * Create a new instance of Axios\n *\n * @param {Object} instanceConfig The default config for the instance\n */\nfunction Axios(instanceConfig) {\n  this.defaults = instanceConfig;\n  this.interceptors = {\n    request: new InterceptorManager(),\n    response: new InterceptorManager()\n  };\n}\n\n/**\n * Dispatch a request\n *\n * @param {Object} config The config specific for this request (merged with this.defaults)\n */\nAxios.prototype.request = function request(config) {\n  /*eslint no-param-reassign:0*/\n  // Allow for axios('example/url'[, config]) a la fetch API\n  if (typeof config === 'string') {\n    config = arguments[1] || {};\n    config.url = arguments[0];\n  } else {\n    config = config || {};\n  }\n\n  config = mergeConfig(this.defaults, config);\n\n  // Set config.method\n  if (config.method) {\n    config.method = config.method.toLowerCase();\n  } else if (this.defaults.method) {\n    config.method = this.defaults.method.toLowerCase();\n  } else {\n    config.method = 'get';\n  }\n\n  // Hook up interceptors middleware\n  var chain = [dispatchRequest, undefined];\n  var promise = Promise.resolve(config);\n\n  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\n    chain.unshift(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\n    chain.push(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  while (chain.length) {\n    promise = promise.then(chain.shift(), chain.shift());\n  }\n\n  return promise;\n};\n\nAxios.prototype.getUri = function getUri(config) {\n  config = mergeConfig(this.defaults, config);\n  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\\?/, '');\n};\n\n// Provide aliases for supported request methods\nutils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, config) {\n    return this.request(mergeConfig(config || {}, {\n      method: method,\n      url: url,\n      data: (config || {}).data\n    }));\n  };\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, data, config) {\n    return this.request(mergeConfig(config || {}, {\n      method: method,\n      url: url,\n      data: data\n    }));\n  };\n});\n\nmodule.exports = Axios;\n","'use strict';\n\n/**\n * A `Cancel` is an object that is thrown when an operation is canceled.\n *\n * @class\n * @param {string=} message The message.\n */\nfunction Cancel(message) {\n  this.message = message;\n}\n\nCancel.prototype.toString = function toString() {\n  return 'Cancel' + (this.message ? ': ' + this.message : '');\n};\n\nCancel.prototype.__CANCEL__ = true;\n\nmodule.exports = Cancel;\n","'use strict';\n\nvar Cancel = require('./Cancel');\n\n/**\n * A `CancelToken` is an object that can be used to request cancellation of an operation.\n *\n * @class\n * @param {Function} executor The executor function.\n */\nfunction CancelToken(executor) {\n  if (typeof executor !== 'function') {\n    throw new TypeError('executor must be a function.');\n  }\n\n  var resolvePromise;\n  this.promise = new Promise(function promiseExecutor(resolve) {\n    resolvePromise = resolve;\n  });\n\n  var token = this;\n  executor(function cancel(message) {\n    if (token.reason) {\n      // Cancellation has already been requested\n      return;\n    }\n\n    token.reason = new Cancel(message);\n    resolvePromise(token.reason);\n  });\n}\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nCancelToken.prototype.throwIfRequested = function throwIfRequested() {\n  if (this.reason) {\n    throw this.reason;\n  }\n};\n\n/**\n * Returns an object that contains a new `CancelToken` and a function that, when called,\n * cancels the `CancelToken`.\n */\nCancelToken.source = function source() {\n  var cancel;\n  var token = new CancelToken(function executor(c) {\n    cancel = c;\n  });\n  return {\n    token: token,\n    cancel: cancel\n  };\n};\n\nmodule.exports = CancelToken;\n","'use strict';\n\nvar utils = require('./utils');\nvar bind = require('./helpers/bind');\nvar Axios = require('./core/Axios');\nvar mergeConfig = require('./core/mergeConfig');\nvar defaults = require('./defaults');\n\n/**\n * Create an instance of Axios\n *\n * @param {Object} defaultConfig The default config for the instance\n * @return {Axios} A new instance of Axios\n */\nfunction createInstance(defaultConfig) {\n  var context = new Axios(defaultConfig);\n  var instance = bind(Axios.prototype.request, context);\n\n  // Copy axios.prototype to instance\n  utils.extend(instance, Axios.prototype, context);\n\n  // Copy context to instance\n  utils.extend(instance, context);\n\n  return instance;\n}\n\n// Create the default instance to be exported\nvar axios = createInstance(defaults);\n\n// Expose Axios class to allow class inheritance\naxios.Axios = Axios;\n\n// Factory for creating new instances\naxios.create = function create(instanceConfig) {\n  return createInstance(mergeConfig(axios.defaults, instanceConfig));\n};\n\n// Expose Cancel & CancelToken\naxios.Cancel = require('./cancel/Cancel');\naxios.CancelToken = require('./cancel/CancelToken');\naxios.isCancel = require('./cancel/isCancel');\n\n// Expose all/spread\naxios.all = function all(promises) {\n  return Promise.all(promises);\n};\naxios.spread = require('./helpers/spread');\n\n// Expose isAxiosError\naxios.isAxiosError = require('./helpers/isAxiosError');\n\nmodule.exports = axios;\n\n// Allow use of default import syntax in TypeScript\nmodule.exports.default = axios;\n","'use strict';\n\n/**\n * Syntactic sugar for invoking a function and expanding an array for arguments.\n *\n * Common use case would be to use `Function.prototype.apply`.\n *\n *  ```js\n *  function f(x, y, z) {}\n *  var args = [1, 2, 3];\n *  f.apply(null, args);\n *  ```\n *\n * With `spread` this example can be re-written.\n *\n *  ```js\n *  spread(function(x, y, z) {})([1, 2, 3]);\n *  ```\n *\n * @param {Function} callback\n * @returns {Function}\n */\nmodule.exports = function spread(callback) {\n  return function wrap(arr) {\n    return callback.apply(null, arr);\n  };\n};\n","'use strict';\n\n/**\n * Determines whether the payload is an error thrown by Axios\n *\n * @param {*} payload The value to test\n * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false\n */\nmodule.exports = function isAxiosError(payload) {\n  return (typeof payload === 'object') && (payload.isAxiosError === true);\n};\n","module.exports = require('./lib/axios');","import axios from \"axios\"\r\nimport router from \"../router\"\r\n\r\nif (process.env.NODE_ENV === \"development\") {\r\n  axios.defaults.baseURL = 'http://localhost:81' //\"http://localhost:81\"\r\n} else {\r\n  axios.defaults.baseURL = 'https://rough-tan-board.glitch.me'\r\n}\r\n\r\naxios.interceptors.request.use(\r\n  (config) => {\r\n    config.headers.token = localStorage.getItem(\"token\") || \"\"\r\n\r\n    if (config.isNeedExtraData !== false) {\r\n      let extraData = { userId: 1 }\r\n      if (config.method === \"get\") {\r\n        config.params = { ...extraData, ...config.data }\r\n      } else {\r\n        config.data = { ...extraData, ...config.data }\r\n      }\r\n    }\r\n    return config\r\n  },\r\n  (err) => {\r\n    return Promise.reject(err)\r\n  }\r\n)\r\n\r\naxios.interceptors.response.use(\r\n  (res) => {\r\n    if (res.data.code === 200) {\r\n      return res.data\r\n    } else if (res.data.code === 400) {\r\n      alert(res.data.message)\r\n    } else {\r\n      return Promise.reject(res)\r\n    }\r\n  },\r\n  (err) => {\r\n    if (err && err.response) {\r\n      switch (err.response.status) {\r\n        case 400:\r\n          err.message = \"请求错误(400)\"\r\n          break\r\n        case 401:\r\n          return router.push(\"/login\")\r\n        case 403:\r\n          err.message = \"拒绝访问(403)\"\r\n          break\r\n        case 404:\r\n          err.message = \"请求出错(404)\"\r\n          break\r\n        case 408:\r\n          err.message = \"请求超时(408)\"\r\n          break\r\n        case 500:\r\n          err.message = \"服务器错误(500)\"\r\n          break\r\n        case 501:\r\n          err.message = \"服务未实现(501)\"\r\n          break\r\n        case 502:\r\n          err.message = \"网络错误(502)\"\r\n          break\r\n        case 503:\r\n          err.message = \"服务不可用(503)\"\r\n          break\r\n        case 504:\r\n          err.message = \"网络超时(504)\"\r\n          break\r\n        case 505:\r\n          err.message = \"HTTP版本不受支持(505)\"\r\n          break\r\n        default:\r\n          err.message = `连接出错(${err.response.status})!`\r\n      }\r\n    } else {\r\n      err.message = \"连接服务器失败!\"\r\n    }\r\n    return Promise.reject(err)\r\n  }\r\n)\r\n\r\nexport const common = async (config) => {\r\n  let res = await axios(config)\r\n  return res\r\n}\r\n","import lightApi from './lightApi'\r\n\r\nconst Api = {\r\n  light: lightApi\r\n}\r\n\r\nexport default Api\r\n\r\n\r\n\r\n","import urls from './urls'\r\nimport { common } from './common'\r\n\r\nconst Api = {\r\n  login: (data) => common({ url: urls.light.login, data, method: 'post' }),\r\n  list: () => common({ url: urls.light.list }),\r\n  myBooks: (data, method) => common({ url: urls.light.myBooks, data, method }),\r\n  detail: (id) => common({ url: urls.light.detail + id })\r\n}\r\n\r\nexport default Api","import Api from \"../../api\"\r\n\r\nexport default {\r\n  async getLightList({ commit }) {\r\n    const res = await Api.light.list()\r\n    commit({ type: 'setLightState', key: 'list', value: res.data })\r\n  },\r\n  async getMyBooks({ commit }) {\r\n    const res = await Api.light.myBooks()\r\n    commit({ type: 'setLightState', key: 'myBooks', value: res.data })\r\n  },\r\n  async addMyBooks({ commit }, payload) {\r\n    const { book } = payload\r\n    const res = await Api.light.myBooks({ book }, 'post')\r\n    commit({ type: 'setLightState', key: 'myBooks', value: res.data }) \r\n    return res   \r\n  },\r\n  async deleteMyBooks({ commit }, payload) {\r\n    const { ids } = payload\r\n    const res = await Api.light.myBooks({ ids }, 'delete')\r\n    commit({ type: 'setLightState', key: 'myBooks', value: res.data }) \r\n    return res  \r\n  },\r\n  async patchMyBooks({ commit }, payload) {\r\n    const res = await Api.light.myBooks({ ...payload }, 'patch')\r\n    commit({ type: 'setLightState', key: 'myBooks', value: res.data }) \r\n    return res  \r\n  },\r\n  async getDetail({ commit }, payload) {\r\n    const res = await Api.light.detail(payload.id)\r\n    res.data.count = 1\r\n    commit({ type: 'setLightState', key: 'detailBook', value: res.data })\r\n  }\r\n}\r\n","import { createStore } from 'vuex'\nimport light from './light'\n\nexport default createStore({\n  modules: {\n    light\n  }\n})\n","import actions from './actions'\r\n\r\nexport default {\r\n  state: {\r\n    header: '小米书城',\r\n    list: [],\r\n    currentId: 0,\r\n    isRealScroll: true,\r\n    isListDialogVisible: false,\r\n    addBook: {},\r\n    myBooks: [],\r\n    detailBook: {}\r\n  },\r\n  mutations: {\r\n    setLightState(state, payload) {\r\n      state[payload.key] = payload.value\r\n      console.log({...state})\r\n    }\r\n  },\r\n  actions\r\n}","import { createApp } from 'vue'\nimport router from './router'\nimport store from './store'\nimport App from './App.vue'\nimport './static/css/light.css'\n\ncreateApp(App).use(store).use(router).mount('#app')\n"],"names":["modulePath","importFunctionName","Function","error","baseURL","URL","location","cleanup","script","revokeObjectURL","src","remove","url","Promise","resolve","reject","absURL","self","moduleMap","moduleBlob","Blob","type","Object","assign","document","createElement","createObjectURL","[object Object]","Error","head","appendChild","p","hasSymbol","Symbol","toStringTag","PolySymbol","name","matchedRouteKey","viewDepthKey","routerKey","routeLocationKey","routerViewLocationKey","isBrowser","window","fn","params","newParams","key","value","Array","isArray","map","noop","TRAILING_SLASH_RE","parseQuery2","location2","currentLocation","path","query","searchString","hash","searchPos","indexOf","hashPos","slice","length","to","from","startsWith","fromSegments","split","toSegments","toPosition","segment","position","join","resolveRelativePath","fullPath","pathname","base","toLowerCase","a","b","aliasOf","keys","isSameRouteLocationParamsValue","isEquivalentArray","every","i","NavigationType","NavigationType2","NavigationDirection","NavigationDirection2","baseEl","querySelector","getAttribute","replace","BEFORE_HASH_RE","computeScrollPosition","left","pageXOffset","top","pageYOffset","scrollToOptions","positionEl","el","isIdSelector","getElementById","offset","docRect","documentElement","getBoundingClientRect","elRect","behavior","getElementPosition","style","scrollTo","delta","history","state","scrollPositions","Map","search","slicePos","includes","pathFromHash","stripBase","back","current","forward","replaced","computeScroll","scroll","createCurrentLocation","historyState","history2","replace2","hashIndex","host","protocol","err","push","data","currentState","buildState","historyNavigation","useHistoryStateNavigation","normalizeBase","historyListeners","listeners","teardowns","pauseState","popStateHandler","fromState","forEach","pop","direction","unknown","replaceState","addEventListener","beforeUnloadListener","pauseListeners","listen","callback","teardown","index","splice","destroy","removeEventListener","useHistoryListeners","routerHistory","go","triggerListeners","createHref","bind","defineProperty","enumerable","get","START_LOCATION_NORMALIZED","matched","meta","redirectedFrom","NavigationFailureSymbol","NavigationFailureType","NavigationFailureType2","BASE_PATH_PARSER_OPTIONS","sensitive","strict","start","end","REGEX_CHARS_RE","diff","aScore","score","bScore","comp","compareScoreArray","ROOT_TOKEN","VALID_PARAM_RE","record","parent","options","parser","segments","extraOptions","pattern","segmentScores","tokenIndex","token","subSegmentScore","repeatable","optional","regexp","re2","RegExp","message","subPattern","re","parse","match","stringify","avoidDuplicatedSlash","endsWith","param","text","tokensToParser","buffer","previousState","tokens","char","customRe","test","tokenizePath","matcher","children","alias","routes","globalOptions","matchers","matcherMap","originalRecord","isRootAdd","mainNormalizedRecord","redirect","beforeEnter","props","normalizeRecordProps","instances","leaveGuards","Set","updateGuards","enterCallbacks","components","default","component","normalizeRouteRecord","mergeOptions","normalizedRecords","aliases","originalMatcher","normalizedRecord","parentPath","connectingSlash","createRouteRecordMatcher","isAliasRecord","matcherRef","isRouteName","delete","removeRoute","comparePathParserScore","set","addRoute","route","createRouterError","paramsFromLocation","filter","k","find","m","parentMatcher","unshift","mergeMetaFields","getRoutes","getRecordMatcher","propsObject","reduce","defaults2","partialOptions","HASH_RE","AMPERSAND_RE","SLASH_RE","EQUAL_RE","IM_RE","PLUS_RE","ENC_BRACKET_OPEN_RE","ENC_BRACKET_CLOSE_RE","ENC_CARET_RE","ENC_BACKTICK_RE","ENC_CURLY_OPEN_RE","ENC_PIPE_RE","ENC_CURLY_CLOSE_RE","ENC_SPACE_RE","encodeURI","commonEncode","encodePath","decodeURIComponent","searchParams","searchParam","eqPos","decode","prototype","hasOwnProperty","currentValue","encodeQueryValue","v","value2","normalizedQuery","handlers","add","handler","list","reset","guard","enterCallbackArray","next","valid","guardReturn","call","guardCall","then","catch","guardType","guards","rawComponent","__vccOpts","guardToPromiseFn","componentPromise","console","resolved","resolvedComponent","obj","__esModule","router2","inject","currentRoute","computed","unref","activeRecordIndex","routeMatched","currentMatched","findIndex","isSameRouteRecord","parentRecordPath","getOriginalPath","isActive","outer","inner","innerValue","outerValue","some","includesParams","isExactActive","isSameRouteLocationParams","href","navigate","e","metaKey","altKey","ctrlKey","shiftKey","defaultPrevented","button","currentTarget","target","preventDefault","guardEvent","RouterLink","String","required","Boolean","activeClass","exactActiveClass","custom","ariaCurrentValue","slots","link","reactive","useLink","elClass","getLinkClass","linkActiveClass","linkExactActiveClass","h","aria-current","onClick","class","propClass","globalClass","defaultClass","slot","slotContent","RouterView","inheritAttrs","attrs","injectedRoute","routeToDisplay","depth","matchedRouteRef","viewRef","ref","instance","oldInstance","oldName","size","flush","matchedRoute","ViewComponent","currentName","normalizeSlot","Component","routePropsOption","routeProps","onVnodeUnmounted","vnode","isUnmounted","promise","scriptRel","seen","__vitePreload","baseModule","deps","relList","supports","all","dep","isCss","cssSelector","rel","as","crossOrigin","res","rej","router","createRouterMatcher","parseQuery$1","parseQuery","stringifyQuery$1","stringifyQuery","beforeGuards","useCallbacks","beforeResolveGuards","afterGuards","shallowRef","pendingLocation","scrollBehavior","scrollRestoration","normalizeParams","applyToParams","paramValue","encodeParams","encodeParam","decodeParams","rawLocation","locationNormalized","parseURL","matchedRoute2","href2","matcherLocation","stringifyQuery2","stringifyURL","normalizeQuery","pushWithRedirect","lastMatched","newTargetLocation","locationAsObject","targetLocation","force","shouldRedirect","handleRedirectRecord","toLocation","failure","aLastIndex","bLastIndex","isSameRouteLocation","isNavigationFailure","triggerError","failure2","finalizeNavigation","checkCanceledNavigation","leavingRecords","updatingRecords","enteringRecords","len","Math","max","recordFrom","recordTo","extractChangingRecords","extractComponentsGuards","reverse","canceledNavigationCheck","checkCanceledNavigationAndReject","runGuardQueue","isPush","isFirstNavigation","removeHistoryListener","_from","info","scrollPosition","getScrollKey","ready","readyHandlers","errorHandlers","resolve2","getSavedScrollPosition","nextTick","scrollToPosition","started","installedApps","parentOrRoute","recordMatcher","hasRoute","routeMatcher","beforeEach","beforeResolve","afterEach","onError","isReady","app","config","globalProperties","$router","this","reactiveRoute","provide","unmountApp","unmount","createRouter","createWebHistory","light","urls","login","myBooks","detail","thisArg","args","arguments","apply","toString","val","getPrototypeOf","l","isArrayBuffer","isBuffer","isUndefined","constructor","isFormData","FormData","isArrayBufferView","ArrayBuffer","isView","isString","isNumber","isObject","isPlainObject","isDate","isFile","isBlob","isFunction","isStream","pipe","isURLSearchParams","URLSearchParams","isStandardBrowserEnv","navigator","product","merge","result","assignValue","extend","trim","str","stripBOM","content","charCodeAt","encodeURIComponent","paramsSerializer","serializedParams","utils","parts","toISOString","JSON","encode","hashmarkIndex","InterceptorManager","use","fulfilled","rejected","eject","id","h2","headers","fns","__CANCEL__","normalizedName","toUpperCase","code","request2","response","request","isAxiosError","toJSON","description","number","fileName","lineNumber","columnNumber","stack","enhanceError","write","expires","domain","secure","cookie","Date","toGMTString","read","now","ignoreDuplicateOf","originURL","msie","userAgent","urlParsingNode","setAttribute","hostname","port","charAt","resolveURL","requestURL","parsed","requestData","requestHeaders","XMLHttpRequest","auth","username","password","unescape","Authorization","btoa","requestedURL","relativeURL","combineURLs","open","method","buildURL","timeout","onreadystatechange","readyState","status","responseURL","responseHeaders","getAllResponseHeaders","line","substr","concat","responseType","responseText","statusText","validateStatus2","validateStatus","createError","onabort","onerror","ontimeout","timeoutErrorMessage","xsrfValue","withCredentials","isURLSameOrigin","xsrfCookieName","cookies","xsrfHeaderName","setRequestHeader","onDownloadProgress","onUploadProgress","upload","cancelToken","cancel","abort","send","DEFAULT_CONTENT_TYPE","Content-Type","adapter","defaults","process","require$$0","transformRequest","transformResponse","maxContentLength","maxBodyLength","common","Accept","throwIfRequested","transformData","reason","isCancel","config1","config2","valueFromConfig2Keys","mergeDeepPropertiesKeys","defaultToConfig2Keys","directMergeKeys","source2","prop","getMergedValue","mergeDeepProperties","axiosKeys","otherKeys","instanceConfig","interceptors","Axios","mergeConfig","chain","dispatchRequest","interceptor","shift","getUri","Cancel","executor","TypeError","resolvePromise","CancelToken","source","c","defaultConfig","context","axios","createInstance","create","require$$1","require$$2","promises","spread","arr","payload","localStorage","getItem","isNeedExtraData","extraData","userId","__assign","async","Api","createStore","modules","header","currentId","isRealScroll","isListDialogVisible","addBook","detailBook","mutations","log","actions","commit","book","ids","count","createApp","App","store","mount"],"mappings":"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"}